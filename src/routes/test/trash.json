{"language":"odin","value":"<pre><code class="language-odin">package main\n\nimport &quot;core:fmt&quot;\nimport &quot;core:mem&quot;\nimport &quot;core:os&quot;\nimport &quot;core:thread&quot;\nimport &quot;core:time&quot;\nimport &quot;core:reflect&quot;\nimport &quot;core:runtime&quot;\nimport &quot;core:intrinsics&quot;\nimport &quot;core:math/big&quot;\n\n/*\n Odin is a general-purpose programming language with distinct typing built\n for high performance, modern systems and data-oriented programming.\n\n Odin is the C alternative for the Joy of Programming.\n\n # Installing Odin\n Getting Started - https://odin-lang.org/docs/install/\n Instructions for downloading and install the Odin compiler and libraries.\n\n # Learning Odin\n Getting Started - https://odin-lang.org/docs/install/\n Getting Started with Odin. Downloading, installing, and getting your\n first program to compile and run.\n Overview of Odin - https://odin-lang.org/docs/overview/\n An overview of the Odin programming language and its features.\n Frequently Asked Questions (FAQ) - https://odin-lang.org/docs/faq/\n Answers to common questions about Odin.\n Packages - https://pkg.odin-lang.org/\n Documentation for all the official packages part of the\n core and vendor library collections.\n Nightly Builds - https://odin-lang.org/docs/nightly/\n Get the latest nightly builds of Odin.\n More Odin Examples - https://github.com/odin-lang/examples\n This repository contains examples of how certain things can be accomplished \n in idiomatic Odin, allowing you learn its semantics, as well as how to use \n parts of the core and vendor package collections.\n*/\n\nthe_basics :: proc() {\n fmt.println(&quot;\\n# the basics&quot;)\n\n { // The Basics\n fmt.println(&quot;Hellope&quot;)\n\n // Lexical elements and literals\n // A comment\n\n my_integer_variable: int // A comment for documentaton\n\n // Multi-line comments begin with /* and end with */. Multi-line comments can\n // also be nested (unlike in C):\n /*\n You can have any text or code here and\n have it be commented.\n /*\n NOTE: comments can be nested!\n */\n */\n\n // String literals are enclosed in double quotes and character literals in single quotes.\n // Special characters are escaped with a backslash \\\n\n some_string := &quot;This is a string&quot;\n _ = 'A' // unicode codepoint literal\n _ = '\\n'\n _ = &quot;C:\\\\Windows\\\\notepad.exe&quot;\n // Raw string literals are enclosed with single back ticks\n _ = `C:\\Windows\\notepad.exe`\n\n // The length of a string in bytes can be found using the built-in `len` procedure:\n _ = len(&quot;Foo&quot;)\n _ = len(some_string)\n\n\n // Numbers\n\n // Numerical literals are written similar to most other programming languages.\n // A useful feature in Odin is that underscores are allowed for better\n // readability: 1_000_000_000 (one billion). A number that contains a dot is a\n // floating point literal: 1.0e9 (one billion). If a number literal is suffixed\n // with i, is an imaginary number literal: 2i (2 multiply the square root of -1).\n\n // Binary literals are prefixed with 0b, octal literals with 0o, and hexadecimal\n // literals 0x. A leading zero does not produce an octal constant (unlike C).\n\n // In Odin, if a numeric constant can be represented by a type without\n // precision loss, it will automatically convert to that type.\n\n x: int = 1.0 // A float literal but it can be represented by an integer without precision loss\n // Constant literals are “untyped” which means that they can implicitly convert to a type.\n\n y: int // `y` is typed of type `int`\n y = 1 // `1` is an untyped integer literal which can implicitly convert to `int`\n\n z: f64 // `z` is typed of type `f64` (64-bit floating point number)\n z = 1 // `1` is an untyped integer literal which can be implicitly converted to `f64`\n // No need for any suffixes or decimal places like in other languages\n // (with the exception of negative zero, which must be given as `-0.0`)\n // CONSTANTS JUST WORK!!!\n\n\n // Assignment statements\n h: int = 123 // declares a new variable `h` with type `int` and assigns a value to it\n h = 637 // assigns a new value to `h`\n\n // `=` is the assignment operator\n\n // You can assign multiple variables with it:\n a, b := 1, &quot;hello&quot; // declares `a` and `b` and infers the types from the assignments\n b, a = &quot;byte&quot;, 0\n\n // Note: `:=` is two tokens, `:` and `=`. The following are equivalent,\n /*\n i: int = 123\n i: = 123\n i := 123\n */\n\n // Constant declarations\n // Constants are entities (symbols) which have an assigned value.\n // The constant’s value cannot be changed.\n // The constant’s value must be able to be evaluated at compile time:\n X :: &quot;what&quot; // constant `X` has the untyped string value &quot;what&quot;\n\n // Constants can be explicitly typed like a variable declaration:\n Y : int : 123\n Z :: Y + 7 // constant computations are possible\n\n _ = my_integer_variable\n _ = x\n }\n}\n\ncontrol_flow :: proc() {\n fmt.println(&quot;\\n# control flow&quot;)\n { // Control flow\n // For loop\n // Odin has only one loop statement, the `for` loop\n\n // Basic for loop\n for i := 0; i &lt; 10; i += 1 {\n fmt.println(i)\n }\n\n // NOTE: Unlike other languages like C, there are no parentheses `( )` surrounding the three components.\n // Braces `{ }` or a `do` are always required\n for i := 0; i &lt; 10; i += 1 { }\n // for i := 0; i &lt; 10; i += 1 do fmt.print()\n\n // The initial and post statements are optional\n i := 0\n for ; i &lt; 10; {\n i += 1\n }\n\n // These semicolons can be dropped. This `for` loop is equivalent to C's `while` loop\n i = 0\n for i &lt; 10 {\n i += 1\n }\n\n // If the condition is omitted, an infinite loop is produced:\n for {\n break\n }\n\n // Range-based for loop\n // The basic for loop\n for j := 0; j &lt; 10; j += 1 {\n fmt.println(j)\n }\n // can also be written\n for j in 0..&lt;10 {\n fmt.println(j)\n }\n for j in 0..=9 {\n fmt.println(j)\n }\n\n // Certain built-in types can be iterated over\n some_string := &quot;Hello, 世界&quot;\n for character in some_string { // Strings are assumed to be UTF-8\n fmt.println(character)\n }\n\n some_array := [3]int{1, 4, 9}\n for value in some_array {\n fmt.println(value)\n }\n\n some_slice := []int{1, 4, 9}\n for value in some_slice {\n fmt.println(value)\n }\n\n some_dynamic_array := [dynamic]int{1, 4, 9}\n defer delete(some_dynamic_array)\n for value in some_dynamic_array {\n fmt.println(value)\n }\n\n\n some_map := map[string]int{&quot;A&quot; = 1, &quot;C&quot; = 9, &quot;B&quot; = 4}\n defer delete(some_map)\n for key in some_map {\n fmt.println(key)\n }\n\n // Alternatively a second index value can be added\n for character, index in some_string {\n fmt.println(index, character)\n }\n for value, index in some_array {\n fmt.println(index, value)\n }\n for value, index in some_slice {\n fmt.println(index, value)\n }\n for value, index in some_dynamic_array {\n fmt.println(index, value)\n }\n for key, value in some_map {\n fmt.println(key, value)\n }\n\n // The iterated values are copies and cannot be written to.\n // The following idiom is useful for iterating over a container in a by-reference manner:\n for _, idx in some_slice {\n some_slice[idx] = (idx+1)*(idx+1)\n }\n\n\n // If statements\n x := 123\n if x &gt;= 0 {\n fmt.println(&quot;x is positive&quot;)\n }\n\n if y := -34; y &lt; 0 {\n fmt.println(&quot;y is negative&quot;)\n }\n\n if y := 123; y &lt; 0 {\n fmt.println(&quot;y is negative&quot;)\n } else if y == 0 {\n fmt.println(&quot;y is zero&quot;)\n } else {\n fmt.println(&quot;y is positive&quot;)\n }\n\n // Switch statement\n // A switch statement is another way to write a sequence of if-else statements.\n // In Odin, the default case is denoted as a case without any expression.\n\n #partial switch arch := ODIN_ARCH; arch {\n case .i386:\n fmt.println(&quot;32-bit&quot;)\n case .amd64:\n fmt.println(&quot;64-bit&quot;)\n case: // default\n fmt.println(&quot;Unsupported architecture&quot;)\n }\n\n // Odin’s `switch` is like one in C or C++, except that Odin only runs the selected case.\n // This means that a `break` statement is not needed at the end of each case.\n // Another important difference is that the case values need not be integers nor constants.\n\n // To achieve a C-like fall through into the next case block, the keyword `fallthrough` can be used.\n one_angry_dwarf :: proc() -&gt; int {\n fmt.println(&quot;one_angry_dwarf was called&quot;)\n return 1\n }\n\n switch j := 0; j {\n case 0:\n case one_angry_dwarf():\n }\n\n // A switch statement without a condition is the same as `switch true`.\n // This can be used to write a clean and long if-else chain and have the\n // ability to break if needed\n\n switch {\n case x &lt; 0:\n fmt.println(&quot;x is negative&quot;)\n case x == 0:\n fmt.println(&quot;x is zero&quot;)\n case:\n fmt.println(&quot;x is positive&quot;)\n }\n\n // A `switch` statement can also use ranges like a range-based loop:\n switch c := 'j'; c {\n case 'A'..='Z', 'a'..='z', '0'..='9':\n fmt.println(&quot;c is alphanumeric&quot;)\n }\n\n switch x {\n case 0..&lt;10:\n fmt.println(&quot;units&quot;)\n case 10..&lt;13:\n fmt.println(&quot;pre-teens&quot;)\n case 13..&lt;20:\n fmt.println(&quot;teens&quot;)\n case 20..&lt;30:\n fmt.println(&quot;twenties&quot;)\n }\n }\n\n { // Defer statement\n // A defer statement defers the execution of a statement until the end of\n // the scope it is in.\n\n // The following will print 4 then 234:\n {\n x := 123\n defer fmt.println(x)\n {\n defer x = 4\n x = 2\n }\n fmt.println(x)\n\n x = 234\n }\n\n // You can defer an entire block too:\n {\n bar :: proc() {}\n\n defer {\n fmt.println(&quot;1&quot;)\n fmt.println(&quot;2&quot;)\n }\n\n cond := false\n defer if cond {\n bar()\n }\n }\n\n // Defer statements are executed in the reverse order that they were declared:\n {\n defer fmt.println(&quot;1&quot;)\n defer fmt.println(&quot;2&quot;)\n defer fmt.println(&quot;3&quot;)\n }\n // Will print 3, 2, and then 1.\n\n if false {\n f, err := os.open(&quot;my_file.txt&quot;)\n if err != 0 {\n // handle error\n }\n defer os.close(f)\n // rest of code\n }\n }\n\n { // When statement\n /*\n The when statement is almost identical to the if statement but with some differences:\n\n * Each condition must be a constant expression as a when\n statement is evaluated at compile time.\n * The statements within a branch do not create a new scope\n * The compiler checks the semantics and code only for statements\n that belong to the first condition that is true\n * An initial statement is not allowed in a when statement\n * when statements are allowed at file scope\n */\n\n // Example\n when ODIN_ARCH == .i386 {\n fmt.println(&quot;32 bit&quot;)\n } else when ODIN_ARCH == .amd64 {\n fmt.println(&quot;64 bit&quot;)\n } else {\n fmt.println(&quot;Unknown architecture&quot;)\n }\n // The when statement is very useful for writing platform specific code.\n // This is akin to the #if construct in C’s preprocessor however, in Odin,\n // it is type checked.\n }\n\n { // Branch statements\n cond, cond1, cond2 := false, false, false\n one_step :: proc() { fmt.println(&quot;one_step&quot;) }\n beyond :: proc() { fmt.println(&quot;beyond&quot;) }\n\n // Break statement\n for cond {\n switch {\n case:\n if cond {\n break // break out of the `switch` statement\n }\n }\n\n break // break out of the `for` statement\n }\n\n loop: for cond1 {\n for cond2 {\n break loop // leaves both loops\n }\n }\n\n // Continue statement\n for cond {\n if cond2 {\n continue\n }\n fmt.println(&quot;Hellope&quot;)\n }\n\n // Fallthrough statement\n\n // Odin’s switch is like one in C or C++, except that Odin only runs the selected\n // case. This means that a break statement is not needed at the end of each case.\n // Another important difference is that the case values need not be integers nor\n // constants.\n\n // fallthrough can be used to explicitly fall through into the next case block:\n\n switch i := 0; i {\n case 0:\n one_step()\n fallthrough\n case 1:\n beyond()\n }\n }\n}\n\n\nnamed_proc_return_parameters :: proc() {\n fmt.println(&quot;\\n# named proc return parameters&quot;)\n\n foo0 :: proc() -&gt; int {\n return 123\n }\n foo1 :: proc() -&gt; (a: int) {\n a = 123\n return\n }\n foo2 :: proc() -&gt; (a, b: int) {\n // Named return values act like variables within the scope\n a = 321\n b = 567\n return b, a\n }\n fmt.println(&quot;foo0 =&quot;, foo0()) // 123\n fmt.println(&quot;foo1 =&quot;, foo1()) // 123\n fmt.println(&quot;foo2 =&quot;, foo2()) // 567 321\n}\n\n\nexplicit_procedure_overloading :: proc() {\n fmt.println(&quot;\\n# explicit procedure overloading&quot;)\n\n add_ints :: proc(a, b: int) -&gt; int {\n x := a + b\n fmt.println(&quot;add_ints&quot;, x)\n return x\n }\n add_floats :: proc(a, b: f32) -&gt; f32 {\n x := a + b\n fmt.println(&quot;add_floats&quot;, x)\n return x\n }\n add_numbers :: proc(a: int, b: f32, c: u8) -&gt; int {\n x := int(a) + int(b) + int(c)\n fmt.println(&quot;add_numbers&quot;, x)\n return x\n }\n\n add :: proc{add_ints, add_floats, add_numbers}\n\n add(int(1), int(2))\n add(f32(1), f32(2))\n add(int(1), f32(2), u8(3))\n\n add(1, 2) // untyped ints coerce to int tighter than f32\n add(1.0, 2.0) // untyped floats coerce to f32 tighter than int\n add(1, 2, 3) // three parameters\n\n // Ambiguous answers\n // add(1.0, 2)\n // add(1, 2.0)\n}\n\nstruct_type :: proc() {\n fmt.println(&quot;\\n# struct type&quot;)\n // A struct is a record type in Odin. It is a collection of fields.\n // Struct fields are accessed by using a dot:\n {\n Vector2 :: struct {\n x: f32,\n y: f32,\n }\n v := Vector2{1, 2}\n v.x = 4\n fmt.println(v.x)\n\n // Struct fields can be accessed through a struct pointer:\n\n v = Vector2{1, 2}\n p := &amp;v\n p.x = 1335\n fmt.println(v)\n\n // We could write p^.x, however, it is to nice abstract the ability\n // to not explicitly dereference the pointer. This is very useful when\n // refactoring code to use a pointer rather than a value, and vice versa.\n }\n {\n // A struct literal can be denoted by providing the struct’s type\n // followed by {}. A struct literal must either provide all the\n // arguments or none:\n Vector3 :: struct {\n x, y, z: f32,\n }\n v: Vector3\n v = Vector3{} // Zero value\n v = Vector3{1, 4, 9}\n\n // You can list just a subset of the fields if you specify the\n // field by name (the order of the named fields does not matter):\n v = Vector3{z=1, y=2}\n assert(v.x == 0)\n assert(v.y == 2)\n assert(v.z == 1)\n }\n {\n // Structs can tagged with different memory layout and alignment requirements:\n\n a :: struct #align 4 {} // align to 4 bytes\n b :: struct #packed {} // remove padding between fields\n c :: struct #raw_union {} // all fields share the same offset (0). This is the same as C's union\n }\n\n}\n\n\nunion_type :: proc() {\n fmt.println(&quot;\\n# union type&quot;)\n {\n val: union{int, bool}\n val = 137\n if i, ok := val.(int); ok {\n fmt.println(i)\n }\n val = true\n fmt.println(val)\n\n val = nil\n\n switch v in val {\n case int: fmt.println(&quot;int&quot;, v)\n case bool: fmt.println(&quot;bool&quot;, v)\n case: fmt.println(&quot;nil&quot;)\n }\n }\n {\n // There is a duality between `any` and `union`\n // An `any` has a pointer to the data and allows for any type (open)\n // A `union` has as binary blob to store the data and allows only certain types (closed)\n // The following code is with `any` but has the same syntax\n val: any\n val = 137\n if i, ok := val.(int); ok {\n fmt.println(i)\n }\n val = true\n fmt.println(val)\n\n val = nil\n\n switch v in val {\n case int: fmt.println(&quot;int&quot;, v)\n case bool: fmt.println(&quot;bool&quot;, v)\n case: fmt.println(&quot;nil&quot;)\n }\n }\n\n Vector3 :: distinct [3]f32\n Quaternion :: distinct quaternion128\n\n // More realistic examples\n {\n // NOTE(bill): For the above basic examples, you may not have any\n // particular use for it. However, my main use for them is not for these\n // simple cases. My main use is for hierarchical types. Many prefer\n // subtyping, embedding the base data into the derived types. Below is\n // an example of this for a basic game Entity.\n\n Entity :: struct {\n id: u64,\n name: string,\n position: Vector3,\n orientation: Quaternion,\n\n derived: any,\n }\n\n Frog :: struct {\n using entity: Entity,\n jump_height: f32,\n }\n\n Monster :: struct {\n using entity: Entity,\n is_robot: bool,\n is_zombie: bool,\n }\n\n // See `parametric_polymorphism` procedure for details\n new_entity :: proc($T: typeid) -&gt; ^Entity {\n t := new(T)\n t.derived = t^\n return t\n }\n\n entity := new_entity(Monster)\n\n switch e in entity.derived {\n case Frog:\n fmt.println(&quot;Ribbit&quot;)\n case Monster:\n if e.is_robot { fmt.println(&quot;Robotic&quot;) }\n if e.is_zombie { fmt.println(&quot;Grrrr!&quot;) }\n fmt.println(&quot;I'm a monster&quot;)\n }\n }\n\n {\n // NOTE(bill): A union can be used to achieve something similar. Instead\n // of embedding the base data into the derived types, the derived data\n // in embedded into the base type. Below is the same example of the\n // basic game Entity but using an union.\n\n Entity :: struct {\n id: u64,\n name: string,\n position: Vector3,\n orientation: Quaternion,\n\n derived: union {Frog, Monster},\n }\n\n Frog :: struct {\n using entity: ^Entity,\n jump_height: f32,\n }\n\n Monster :: struct {\n using entity: ^Entity,\n is_robot: bool,\n is_zombie: bool,\n }\n\n // See `parametric_polymorphism` procedure for details\n new_entity :: proc($T: typeid) -&gt; ^Entity {\n t := new(Entity)\n t.derived = T{entity = t}\n return t\n }\n\n entity := new_entity(Monster)\n\n switch e in entity.derived {\n case Frog:\n fmt.println(&quot;Ribbit&quot;)\n case Monster:\n if e.is_robot { fmt.println(&quot;Robotic&quot;) }\n if e.is_zombie { fmt.println(&quot;Grrrr!&quot;) }\n }\n\n // NOTE(bill): As you can see, the usage code has not changed, only its\n // memory layout. Both approaches have their own advantages but they can\n // be used together to achieve different results. The subtyping approach\n // can allow for a greater control of the memory layout and memory\n // allocation, e.g. storing the derivatives together. However, this is\n // also its disadvantage. You must either preallocate arrays for each\n // derivative separation (which can be easily missed) or preallocate a\n // bunch of &quot;raw&quot; memory; determining the maximum size of the derived\n // types would require the aid of metaprogramming. Unions solve this\n // particular problem as the data is stored with the base data.\n // Therefore, it is possible to preallocate, e.g. [100]Entity.\n\n // It should be noted that the union approach can have the same memory\n // layout as the any and with the same type restrictions by using a\n // pointer type for the derivatives.\n\n /*\n Entity :: struct {\n ...\n derived: union{^Frog, ^Monster},\n }\n\n Frog :: struct {\n using entity: Entity,\n ...\n }\n Monster :: struct {\n using entity: Entity,\n ...\n\n }\n new_entity :: proc(T: type) -&gt; ^Entity {\n t := new(T)\n t.derived = t\n return t\n }\n */\n }\n}\n\nusing_statement :: proc() {\n fmt.println(&quot;\\n# using statement&quot;)\n // using can used to bring entities declared in a scope/namespace\n // into the current scope. This can be applied to import names, struct\n // fields, procedure fields, and struct values.\n\n Vector3 :: struct{x, y, z: f32}\n {\n Entity :: struct {\n position: Vector3,\n orientation: quaternion128,\n }\n\n // It can used like this:\n foo0 :: proc(entity: ^Entity) {\n fmt.println(entity.position.x, entity.position.y, entity.position.z)\n }\n\n // The entity members can be brought into the procedure scope by using it:\n foo1 :: proc(entity: ^Entity) {\n using entity\n fmt.println(position.x, position.y, position.z)\n }\n\n // The using can be applied to the parameter directly:\n foo2 :: proc(using entity: ^Entity) {\n fmt.println(position.x, position.y, position.z)\n }\n\n // It can also be applied to sub-fields:\n foo3 :: proc(entity: ^Entity) {\n using entity.position\n fmt.println(x, y, z)\n }\n }\n {\n // We can also apply the using statement to the struct fields directly,\n // making all the fields of position appear as if they on Entity itself:\n Entity :: struct {\n using position: Vector3,\n orientation: quaternion128,\n }\n foo :: proc(entity: ^Entity) {\n fmt.println(entity.x, entity.y, entity.z)\n }\n\n\n // Subtype polymorphism\n // It is possible to get subtype polymorphism, similar to inheritance-like\n // functionality in C++, but without the requirement of vtables or unknown\n // struct layout:\n\n Colour :: struct {r, g, b, a: u8}\n Frog :: struct {\n ribbit_volume: f32,\n using entity: Entity,\n colour: Colour,\n }\n\n frog: Frog\n // Both work\n foo(&amp;frog.entity)\n foo(&amp;frog)\n frog.x = 123\n\n // Note: using can be applied to arbitrarily many things, which allows\n // the ability to have multiple subtype polymorphism (but also its issues).\n\n // Note: using’d fields can still be referred by name.\n }\n}\n\n\nimplicit_context_system :: proc() {\n fmt.println(&quot;\\n# implicit context system&quot;)\n // In each scope, there is an implicit value named context. This\n // context variable is local to each scope and is implicitly passed\n // by pointer to any procedure call in that scope (if the procedure\n // has the Odin calling convention).\n\n // The main purpose of the implicit context system is for the ability\n // to intercept third-party code and libraries and modify their\n // functionality. One such case is modifying how a library allocates\n // something or logs something. In C, this was usually achieved with\n // the library defining macros which could be overridden so that the\n // user could define what he wanted. However, not many libraries\n // supported this in many languages by default which meant intercepting\n // third-party code to see what it does and to change how it does it is\n // not possible.\n\n c := context // copy the current scope's context\n\n context.user_index = 456\n {\n context.allocator = my_custom_allocator()\n context.user_index = 123\n what_a_fool_believes() // the `context` for this scope is implicitly passed to `what_a_fool_believes`\n }\n\n // `context` value is local to the scope it is in\n assert(context.user_index == 456)\n\n what_a_fool_believes :: proc() {\n c := context // this `context` is the same as the parent procedure that it was called from\n // From this example, context.user_index == 123\n // An context.allocator is assigned to the return value of `my_custom_allocator()`\n assert(context.user_index == 123)\n\n // The memory management procedure use the `context.allocator` by\n // default unless explicitly specified otherwise\n china_grove := new(int)\n free(china_grove)\n\n _ = c\n }\n\n my_custom_allocator :: mem.nil_allocator\n _ = c\n\n // By default, the context value has default values for its parameters which is\n // decided in the package runtime. What the defaults are are compiler specific.\n\n // To see what the implicit context value contains, please see the following\n // definition in package runtime.\n}\n\nparametric_polymorphism :: proc() {\n fmt.println(&quot;\\n# parametric polymorphism&quot;)\n\n print_value :: proc(value: $T) {\n fmt.printf(&quot;print_value: %T %v\\n&quot;, value, value)\n }\n\n v1: int = 1\n v2: f32 = 2.1\n v3: f64 = 3.14\n v4: string = &quot;message&quot;\n\n print_value(v1)\n print_value(v2)\n print_value(v3)\n print_value(v4)\n\n fmt.println()\n\n add :: proc(p, q: $T) -&gt; T {\n x: T = p + q\n return x\n }\n\n a := add(3, 4)\n fmt.printf(&quot;a: %T = %v\\n&quot;, a, a)\n\n b := add(3.2, 4.3)\n fmt.printf(&quot;b: %T = %v\\n&quot;, b, b)\n\n // This is how `new` is implemented\n alloc_type :: proc($T: typeid) -&gt; ^T {\n t := cast(^T)alloc(size_of(T), align_of(T))\n t^ = T{} // Use default initialization value\n return t\n }\n\n copy_slice :: proc(dst, src: []$T) -&gt; int {\n n := min(len(dst), len(src))\n if n &gt; 0 {\n mem.copy(&amp;dst[0], &amp;src[0], n*size_of(T))\n }\n return n\n }\n\n double_params :: proc(a: $A, b: $B) -&gt; A {\n return a + A(b)\n }\n\n fmt.println(double_params(12, 1.345))\n\n\n\n { // Polymorphic Types and Type Specialization\n Table_Slot :: struct($Key, $Value: typeid) {\n occupied: bool,\n hash: u32,\n key: Key,\n value: Value,\n }\n TABLE_SIZE_MIN :: 32\n Table :: struct($Key, $Value: typeid) {\n count: int,\n allocator: mem.Allocator,\n slots: []Table_Slot(Key, Value),\n }\n\n // Only allow types that are specializations of a (polymorphic) slice\n make_slice :: proc($T: typeid/[]$E, len: int) -&gt; T {\n return make(T, len)\n }\n\n // Only allow types that are specializations of `Table`\n allocate :: proc(table: ^$T/Table, capacity: int) {\n c := context\n if table.allocator.procedure != nil {\n c.allocator = table.allocator\n }\n context = c\n\n table.slots = make_slice(type_of(table.slots), max(capacity, TABLE_SIZE_MIN))\n }\n\n expand :: proc(table: ^$T/Table) {\n c := context\n if table.allocator.procedure != nil {\n c.allocator = table.allocator\n }\n context = c\n\n old_slots := table.slots\n defer delete(old_slots)\n\n cap := max(2*len(table.slots), TABLE_SIZE_MIN)\n allocate(table, cap)\n\n for s in old_slots {\n if s.occupied {\n put(table, s.key, s.value)\n }\n }\n }\n\n // Polymorphic determination of a polymorphic struct\n // put :: proc(table: ^$T/Table, key: T.Key, value: T.Value) {\n put :: proc(table: ^Table($Key, $Value), key: Key, value: Value) {\n hash := get_hash(key) // Ad-hoc method which would fail in a different scope\n index := find_index(table, key, hash)\n if index &lt; 0 {\n if f64(table.count) &gt;= 0.75*f64(len(table.slots)) {\n expand(table)\n }\n assert(table.count &lt;= len(table.slots))\n\n index = int(hash % u32(len(table.slots)))\n\n for table.slots[index].occupied {\n if index += 1; index &gt;= len(table.slots) {\n index = 0\n }\n }\n\n table.count += 1\n }\n\n slot := &amp;table.slots[index]\n slot.occupied = true\n slot.hash = hash\n slot.key = key\n slot.value = value\n }\n\n\n // find :: proc(table: ^$T/Table, key: T.Key) -&gt; (T.Value, bool) {\n find :: proc(table: ^Table($Key, $Value), key: Key) -&gt; (Value, bool) {\n hash := get_hash(key)\n index := find_index(table, key, hash)\n if index &lt; 0 {\n return Value{}, false\n }\n return table.slots[index].value, true\n }\n\n find_index :: proc(table: ^Table($Key, $Value), key: Key, hash: u32) -&gt; int {\n if len(table.slots) &lt;= 0 {\n return -1\n }\n\n index := int(hash % u32(len(table.slots)))\n for table.slots[index].occupied {\n if table.slots[index].hash == hash {\n if table.slots[index].key == key {\n return index\n }\n }\n\n if index += 1; index &gt;= len(table.slots) {\n index = 0\n }\n }\n\n return -1\n }\n\n get_hash :: proc(s: string) -&gt; u32 { // fnv32a\n h: u32 = 0x811c9dc5\n for i in 0..&lt;len(s) {\n h = (h ~ u32(s[i])) * 0x01000193\n }\n return h\n }\n\n\n table: Table(string, int)\n\n for i in 0..=36 { put(&amp;table, &quot;Hellope&quot;, i) }\n for i in 0..=42 { put(&amp;table, &quot;World!&quot;, i) }\n\n found, _ := find(&amp;table, &quot;Hellope&quot;)\n fmt.printf(&quot;`found` is %v\\n&quot;, found)\n\n found, _ = find(&amp;table, &quot;World!&quot;)\n fmt.printf(&quot;`found` is %v\\n&quot;, found)\n\n // I would not personally design a hash table like this in production\n // but this is a nice basic example\n // A better approach would either use a `u64` or equivalent for the key\n // and let the user specify the hashing function or make the user store\n // the hashing procedure with the table\n }\n\n { // Parametric polymorphic union\n Error :: enum {\n Foo0,\n Foo1,\n Foo2,\n Foo3,\n }\n Para_Union :: union($T: typeid) {T, Error}\n r: Para_Union(int)\n fmt.println(typeid_of(type_of(r)))\n\n fmt.println(r)\n r = 123\n fmt.println(r)\n r = Error.Foo0 // r = .Foo0 is allow too, see implicit selector expressions below\n fmt.println(r)\n }\n\n { // Polymorphic names\n foo :: proc($N: $I, $T: typeid) -&gt; (res: [N]T) {\n // `N` is the constant value passed\n // `I` is the type of N\n // `T` is the type passed\n fmt.printf(&quot;Generating an array of type %v from the value %v of type %v\\n&quot;,\n typeid_of(type_of(res)), N, typeid_of(I))\n for i in 0..&lt;N {\n res[i] = T(i*i)\n }\n return\n }\n\n T :: int\n array := foo(4, T)\n for v, i in array {\n assert(v == T(i*i))\n }\n\n // Matrix multiplication\n mul :: proc(a: [$M][$N]$T, b: [N][$P]T) -&gt; (c: [M][P]T) {\n for i in 0..&lt;M {\n for j in 0..&lt;P {\n for k in 0..&lt;N {\n c[i][j] += a[i][k] * b[k][j]\n }\n }\n }\n return\n }\n\n x := [2][3]f32{\n {1, 2, 3},\n {3, 2, 1},\n }\n y := [3][2]f32{\n {0, 8},\n {6, 2},\n {8, 4},\n }\n z := mul(x, y)\n assert(z == {{36, 24}, {20, 32}})\n }\n}\n\n\nprefix_table := [?]string{\n &quot;White&quot;,\n &quot;Red&quot;,\n &quot;Green&quot;,\n &quot;Blue&quot;,\n &quot;Octarine&quot;,\n &quot;Black&quot;,\n}\n\nprint_mutex := b64(false)\n\nthreading_example :: proc() {\n fmt.println(&quot;\\n# threading_example&quot;)\n\n did_acquire :: proc(m: ^b64) -&gt; (acquired: bool) {\n res, ok := intrinsics.atomic_compare_exchange_strong(m, false, true)\n return ok &amp;&amp; res == false\n }\n\n { // Basic Threads\n fmt.println(&quot;\\n## Basic Threads&quot;)\n worker_proc :: proc(t: ^thread.Thread) {\n for iteration in 1..=5 {\n fmt.printf(&quot;Thread %d is on iteration %d\\n&quot;, t.user_index, iteration)\n fmt.printf(&quot;`%s`: iteration %d\\n&quot;, prefix_table[t.user_index], iteration)\n time.sleep(1 * time.Millisecond)\n }\n }\n\n threads := make([dynamic]^thread.Thread, 0, len(prefix_table))\n defer delete(threads)\n\n for in prefix_table {\n if t := thread.create(worker_proc); t != nil {\n t.init_context = context\n t.user_index = len(threads)\n append(&amp;threads, t)\n thread.start(t)\n }\n }\n\n for len(threads) &gt; 0 {\n for i := 0; i &lt; len(threads); /**/ {\n if t := threads[i]; thread.is_done(t) {\n fmt.printf(&quot;Thread %d is done\\n&quot;, t.user_index)\n thread.destroy(t)\n\n ordered_remove(&amp;threads, i)\n } else {\n i += 1\n }\n }\n }\n }\n\n { // Thread Pool\n fmt.println(&quot;\\n## Thread Pool&quot;)\n task_proc :: proc(t: thread.Task) {\n index := t.user_index % len(prefix_table)\n for iteration in 1..=5 {\n for !did_acquire(&amp;print_mutex) { thread.yield() } // Allow one thread to print at a time.\n\n fmt.printf(&quot;Worker Task %d is on iteration %d\\n&quot;, t.user_index, iteration)\n fmt.printf(&quot;`%s`: iteration %d\\n&quot;, prefix_table[index], iteration)\n\n print_mutex = false\n\n time.sleep(1 * time.Millisecond)\n }\n }\n\n N :: 3\n\n pool: thread.Pool\n thread.pool_init(pool=&amp;pool, thread_count=N, allocator=context.allocator)\n defer thread.pool_destroy(&amp;pool)\n\n\n for i in 0..&lt;30 {\n // be mindful of the allocator used for tasks. The allocator needs to be thread safe, or be owned by the task for exclusive use \n thread.pool_add_task(pool=&amp;pool, procedure=task_proc, data=nil, user_index=i, allocator=context.allocator)\n }\n\n thread.pool_start(&amp;pool)\n\n {\n // Wait a moment before we cancel a thread\n time.sleep(5 * time.Millisecond)\n\n // Allow one thread to print at a time.\n for !did_acquire(&amp;print_mutex) { thread.yield() }\n\n thread.terminate(pool.threads[N - 1], 0)\n fmt.println(&quot;Canceled last thread&quot;)\n print_mutex = false\n }\n\n thread.pool_finish(&amp;pool)\n }\n}\n\n\narray_programming :: proc() {\n fmt.println(&quot;\\n# array programming&quot;)\n {\n a := [3]f32{1, 2, 3}\n b := [3]f32{5, 6, 7}\n c := a * b\n d := a + b\n e := 1 + (c - d) / 2\n fmt.printf(&quot;%.1f\\n&quot;, e) // [0.5, 3.0, 6.5]\n }\n\n {\n a := [3]f32{1, 2, 3}\n b := swizzle(a, 2, 1, 0)\n assert(b == [3]f32{3, 2, 1})\n\n c := swizzle(a, 0, 0)\n assert(c == [2]f32{1, 1})\n assert(c == 1)\n }\n\n {\n Vector3 :: distinct [3]f32\n a := Vector3{1, 2, 3}\n b := Vector3{5, 6, 7}\n c := (a * b)/2 + 1\n d := c.x + c.y + c.z\n fmt.printf(&quot;%.1f\\n&quot;, d) // 22.0\n\n cross :: proc(a, b: Vector3) -&gt; Vector3 {\n i := swizzle(a, 1, 2, 0) * swizzle(b, 2, 0, 1)\n j := swizzle(a, 2, 0, 1) * swizzle(b, 1, 2, 0)\n return i - j\n }\n\n cross_shorter :: proc(a, b: Vector3) -&gt; Vector3 {\n i := a.yzx * b.zxy\n j := a.zxy * b.yzx\n return i - j\n }\n\n blah :: proc(a: Vector3) -&gt; f32 {\n return a.x + a.y + a.z\n }\n\n x := cross(a, b)\n fmt.println(x)\n fmt.println(blah(x))\n }\n}\n\nmap_type :: proc() {\n fmt.println(&quot;\\n# map type&quot;)\n\n m := make(map[string]int)\n defer delete(m)\n\n m[&quot;Bob&quot;] = 2\n m[&quot;Ted&quot;] = 5\n fmt.println(m[&quot;Bob&quot;])\n\n delete_key(&amp;m, &quot;Ted&quot;)\n\n // If an element of a key does not exist, the zero value of the\n // element will be returned. To check to see if an element exists\n // can be done in two ways:\n elem, ok := m[&quot;Bob&quot;]\n exists := &quot;Bob&quot; in m\n _, _ = elem, ok\n _ = exists\n}\n\nimplicit_selector_expression :: proc() {\n fmt.println(&quot;\\n# implicit selector expression&quot;)\n\n Foo :: enum {A, B, C}\n\n f: Foo\n f = Foo.A\n f = .A\n\n BAR :: bit_set[Foo]{.B, .C}\n\n switch f {\n case .A:\n fmt.println(&quot;HITHER&quot;)\n case .B:\n fmt.println(&quot;NEVER&quot;)\n case .C:\n fmt.println(&quot;FOREVER&quot;)\n }\n\n my_map := make(map[Foo]int)\n defer delete(my_map)\n\n my_map[.A] = 123\n my_map[Foo.B] = 345\n\n fmt.println(my_map[.A] + my_map[Foo.B] + my_map[.C])\n}\n\n\npartial_switch :: proc() {\n fmt.println(&quot;\\n# partial_switch&quot;)\n { // enum\n Foo :: enum {\n A,\n B,\n C,\n D,\n }\n\n f := Foo.A\n switch f {\n case .A: fmt.println(&quot;A&quot;)\n case .B: fmt.println(&quot;B&quot;)\n case .C: fmt.println(&quot;C&quot;)\n case .D: fmt.println(&quot;D&quot;)\n case: fmt.println(&quot;?&quot;)\n }\n\n #partial switch f {\n case .A: fmt.println(&quot;A&quot;)\n case .D: fmt.println(&quot;D&quot;)\n }\n }\n { // union\n Foo :: union {int, bool}\n f: Foo = 123\n switch in f {\n case int: fmt.println(&quot;int&quot;)\n case bool: fmt.println(&quot;bool&quot;)\n case:\n }\n\n #partial switch in f {\n case bool: fmt.println(&quot;bool&quot;)\n }\n }\n}\n\ncstring_example :: proc() {\n fmt.println(&quot;\\n# cstring_example&quot;)\n\n W :: &quot;Hellope&quot;\n X :: cstring(W)\n Y :: string(X)\n\n w := W\n _ = w\n x: cstring = X\n y: string = Y\n z := string(x)\n fmt.println(x, y, z)\n fmt.println(len(x), len(y), len(z))\n fmt.println(len(W), len(X), len(Y))\n // IMPORTANT NOTE for cstring variables\n // len(cstring) is O(N)\n // cast(string)cstring is O(N)\n}\n\nbit_set_type :: proc() {\n fmt.println(&quot;\\n# bit_set type&quot;)\n\n {\n Day :: enum {\n Sunday,\n Monday,\n Tuesday,\n Wednesday,\n Thursday,\n Friday,\n Saturday,\n }\n\n Days :: distinct bit_set[Day]\n WEEKEND :: Days{.Sunday, .Saturday}\n\n d: Days\n d = {.Sunday, .Monday}\n e := d + WEEKEND\n e += {.Monday}\n fmt.println(d, e)\n\n ok := .Saturday in e // `in` is only allowed for `map` and `bit_set` types\n fmt.println(ok)\n if .Saturday in e {\n fmt.println(&quot;Saturday in&quot;, e)\n }\n X :: .Saturday in WEEKEND // Constant evaluation\n fmt.println(X)\n fmt.println(&quot;Cardinality:&quot;, card(e))\n }\n {\n x: bit_set['A'..='Z']\n #assert(size_of(x) == size_of(u32))\n y: bit_set[0..=8; u16]\n fmt.println(typeid_of(type_of(x))) // bit_set[A..=Z]\n fmt.println(typeid_of(type_of(y))) // bit_set[0..=8; u16]\n\n x += {'F'}\n assert('F' in x)\n x -= {'F'}\n assert('F' not_in x)\n\n y += {1, 4, 2}\n assert(2 in y)\n }\n {\n Letters :: bit_set['A'..='Z']\n a := Letters{'A', 'B'}\n b := Letters{'A', 'B', 'C', 'D', 'F'}\n c := Letters{'A', 'B'}\n\n assert(a &lt;= b) // 'a' is a subset of 'b'\n assert(b &gt;= a) // 'b' is a superset of 'a'\n assert(a &lt; b) // 'a' is a strict subset of 'b'\n assert(b &gt; a) // 'b' is a strict superset of 'a'\n\n assert(!(a &lt; c)) // 'a' is a not strict subset of 'c'\n assert(!(c &gt; a)) // 'c' is a not strict superset of 'a'\n }\n}\n\ndeferred_procedure_associations :: proc() {\n fmt.println(&quot;\\n# deferred procedure associations&quot;)\n\n @(deferred_out=closure)\n open :: proc(s: string) -&gt; bool {\n fmt.println(s)\n return true\n }\n\n closure :: proc(ok: bool) {\n fmt.println(&quot;Goodbye?&quot;, ok)\n }\n\n if open(&quot;Welcome&quot;) {\n fmt.println(&quot;Something in the middle, mate.&quot;)\n }\n}\n\nreflection :: proc() {\n fmt.println(&quot;\\n# reflection&quot;)\n\n Foo :: struct {\n x: int `tag1`,\n y: string `json:&quot;y_field&quot;`,\n z: bool, // no tag\n }\n\n id := typeid_of(Foo)\n names := reflect.struct_field_names(id)\n types := reflect.struct_field_types(id)\n tags := reflect.struct_field_tags(id)\n\n assert(len(names) == len(types) &amp;&amp; len(names) == len(tags))\n\n fmt.println(&quot;Foo :: struct {&quot;)\n for tag, i in tags {\n name, type := names[i], types[i]\n if tag != &quot;&quot; {\n fmt.printf(&quot;\\t%s: %T `%s`,\\n&quot;, name, type, tag)\n } else {\n fmt.printf(&quot;\\t%s: %T,\\n&quot;, name, type)\n }\n }\n fmt.println(&quot;}&quot;)\n\n\n for tag, i in tags {\n if val, ok := reflect.struct_tag_lookup(tag, &quot;json&quot;); ok {\n fmt.printf(&quot;json: %s -&gt; %s\\n&quot;, names[i], val)\n }\n }\n}\n\nquaternions :: proc() {\n // Not just an April Fool's Joke any more, but a fully working thing!\n fmt.println(&quot;\\n# quaternions&quot;)\n\n { // Quaternion operations\n q := 1 + 2i + 3j + 4k\n r := quaternion(5, 6, 7, 8)\n t := q * r\n fmt.printf(&quot;(%v) * (%v) = %v\\n&quot;, q, r, t)\n v := q / r\n fmt.printf(&quot;(%v) / (%v) = %v\\n&quot;, q, r, v)\n u := q + r\n fmt.printf(&quot;(%v) + (%v) = %v\\n&quot;, q, r, u)\n s := q - r\n fmt.printf(&quot;(%v) - (%v) = %v\\n&quot;, q, r, s)\n }\n { // The quaternion types\n q128: quaternion128 // 4xf32\n q256: quaternion256 // 4xf64\n q128 = quaternion(1, 0, 0, 0)\n q256 = 1 // quaternion(1, 0, 0, 0)\n }\n { // Built-in procedures\n q := 1 + 2i + 3j + 4k\n fmt.println(&quot;q =&quot;, q)\n fmt.println(&quot;real(q) =&quot;, real(q))\n fmt.println(&quot;imag(q) =&quot;, imag(q))\n fmt.println(&quot;jmag(q) =&quot;, jmag(q))\n fmt.println(&quot;kmag(q) =&quot;, kmag(q))\n fmt.println(&quot;conj(q) =&quot;, conj(q))\n fmt.println(&quot;abs(q) =&quot;, abs(q))\n }\n { // Conversion of a complex type to a quaternion type\n c := 1 + 2i\n q := quaternion256(c)\n fmt.println(c)\n fmt.println(q)\n }\n { // Memory layout of Quaternions\n q := 1 + 2i + 3j + 4k\n a := transmute([4]f64)q\n fmt.println(&quot;Quaternion memory layout: xyzw/(ijkr)&quot;)\n fmt.println(q) // 1.000+2.000i+3.000j+4.000k\n fmt.println(a) // [2.000, 3.000, 4.000, 1.000]\n }\n}\n\nunroll_for_statement :: proc() {\n fmt.println(&quot;\\n#'#unroll for' statements&quot;)\n\n // '#unroll for' works the same as if the 'inline' prefix did not\n // exist but these ranged loops are explicitly unrolled which can\n // be very very useful for certain optimizations\n\n fmt.println(&quot;Ranges&quot;)\n #unroll for x, i in 1..&lt;4 {\n fmt.println(x, i)\n }\n\n fmt.println(&quot;Strings&quot;)\n #unroll for r, i in &quot;Hello, 世界&quot; {\n fmt.println(r, i)\n }\n\n fmt.println(&quot;Arrays&quot;)\n #unroll for elem, idx in ([4]int{1, 4, 9, 16}) {\n fmt.println(elem, idx)\n }\n\n\n Foo_Enum :: enum {\n A = 1,\n B,\n C = 6,\n D,\n }\n fmt.println(&quot;Enum types&quot;)\n #unroll for elem, idx in Foo_Enum {\n fmt.println(elem, idx)\n }\n}\n\nwhere_clauses :: proc() {\n fmt.println(&quot;\\n#procedure 'where' clauses&quot;)\n\n { // Sanity checks\n simple_sanity_check :: proc(x: [2]int)\n where len(x) &gt; 1,\n type_of(x) == [2]int {\n fmt.println(x)\n }\n }\n { // Parametric polymorphism checks\n cross_2d :: proc(a, b: $T/[2]$E) -&gt; E\n where intrinsics.type_is_numeric(E) {\n return a.x*b.y - a.y*b.x\n }\n cross_3d :: proc(a, b: $T/[3]$E) -&gt; T\n where intrinsics.type_is_numeric(E) {\n x := a.y*b.z - a.z*b.y\n y := a.z*b.x - a.x*b.z\n z := a.x*b.y - a.y*b.z\n return T{x, y, z}\n }\n\n a := [2]int{1, 2}\n b := [2]int{5, -3}\n fmt.println(cross_2d(a, b))\n\n x := [3]f32{1, 4, 9}\n y := [3]f32{-5, 0, 3}\n fmt.println(cross_3d(x, y))\n\n // Failure case\n // i := [2]bool{true, false}\n // j := [2]bool{false, true}\n // fmt.println(cross_2d(i, j))\n\n }\n\n { // Procedure groups usage\n foo :: proc(x: [$N]int) -&gt; bool\n where N &gt; 2 {\n fmt.println(#procedure, &quot;was called with the parameter&quot;, x)\n return true\n }\n\n bar :: proc(x: [$N]int) -&gt; bool\n where 0 &lt; N,\n N &lt;= 2 {\n fmt.println(#procedure, &quot;was called with the parameter&quot;, x)\n return false\n }\n\n baz :: proc{foo, bar}\n\n x := [3]int{1, 2, 3}\n y := [2]int{4, 9}\n ok_x := baz(x)\n ok_y := baz(y)\n assert(ok_x == true)\n assert(ok_y == false)\n }\n\n { // Record types\n Foo :: struct($T: typeid, $N: int)\n where intrinsics.type_is_integer(T),\n N &gt; 2 {\n x: [N]T,\n y: [N-2]T,\n }\n\n T :: i32\n N :: 5\n f: Foo(T, N)\n #assert(size_of(f) == (N+N-2)*size_of(T))\n }\n}\n\n\nwhen ODIN_OS == .Windows {\n foreign import kernel32 &quot;system:kernel32.lib&quot;\n}\n\nforeign_system :: proc() {\n fmt.println(&quot;\\n#foreign system&quot;)\n when ODIN_OS == .Windows {\n // It is sometimes necessarily to interface with foreign code,\n // such as a C library. In Odin, this is achieved through the\n // foreign system. You can “import” a library into the code\n // using the same semantics as a normal import declaration.\n\n // This foreign import declaration will create a\n // “foreign import name” which can then be used to associate\n // entities within a foreign block.\n\n foreign kernel32 {\n ExitProcess :: proc &quot;stdcall&quot; (exit_code: u32) ---\n }\n\n // Foreign procedure declarations have the cdecl/c calling\n // convention by default unless specified otherwise. Due to\n // foreign procedures do not have a body declared within this\n // code, you need append the --- symbol to the end to distinguish\n // it as a procedure literal without a body and not a procedure type.\n\n // The attributes system can be used to change specific properties\n // of entities declared within a block:\n\n @(default_calling_convention = &quot;std&quot;)\n foreign kernel32 {\n @(link_name=&quot;GetLastError&quot;) get_last_error :: proc() -&gt; i32 ---\n }\n\n // Example using the link_prefix attribute\n @(default_calling_convention = &quot;std&quot;)\n @(link_prefix = &quot;Get&quot;)\n foreign kernel32 {\n LastError :: proc() -&gt; i32 ---\n }\n }\n}\n\nranged_fields_for_array_compound_literals :: proc() {\n fmt.println(&quot;\\n#ranged fields for array compound literals&quot;)\n { // Normal Array Literal\n foo := [?]int{1, 4, 9, 16}\n fmt.println(foo)\n }\n { // Indexed\n foo := [?]int{\n 3 = 16,\n 1 = 4,\n 2 = 9,\n 0 = 1,\n }\n fmt.println(foo)\n }\n { // Ranges\n i := 2\n foo := [?]int {\n 0 = 123,\n 5..=9 = 54,\n 10..&lt;16 = i*3 + (i-1)*2,\n }\n #assert(len(foo) == 16)\n fmt.println(foo) // [123, 0, 0, 0, 0, 54, 54, 54, 54, 54, 8, 8, 8, 8, 8]\n }\n { // Slice and Dynamic Array support\n i := 2\n foo_slice := []int {\n 0 = 123,\n 5..=9 = 54,\n 10..&lt;16 = i*3 + (i-1)*2,\n }\n assert(len(foo_slice) == 16)\n fmt.println(foo_slice) // [123, 0, 0, 0, 0, 54, 54, 54, 54, 54, 8, 8, 8, 8, 8]\n\n foo_dynamic_array := [dynamic]int {\n 0 = 123,\n 5..=9 = 54,\n 10..&lt;16 = i*3 + (i-1)*2,\n }\n assert(len(foo_dynamic_array) == 16)\n fmt.println(foo_dynamic_array) // [123, 0, 0, 0, 0, 54, 54, 54, 54, 54, 8, 8, 8, 8, 8]\n }\n}\n\ndeprecated_attribute :: proc() {\n @(deprecated=&quot;Use foo_v2 instead&quot;)\n foo_v1 :: proc(x: int) {\n fmt.println(&quot;foo_v1&quot;)\n }\n foo_v2 :: proc(x: int) {\n fmt.println(&quot;foo_v2&quot;)\n }\n\n // NOTE: Uncomment to see the warning messages\n // foo_v1(1)\n}\n\nrange_statements_with_multiple_return_values :: proc() {\n fmt.println(&quot;\\n#range statements with multiple return values&quot;)\n My_Iterator :: struct {\n index: int,\n data: []i32,\n }\n make_my_iterator :: proc(data: []i32) -&gt; My_Iterator {\n return My_Iterator{data = data}\n }\n my_iterator :: proc(it: ^My_Iterator) -&gt; (val: i32, idx: int, cond: bool) {\n if cond = it.index &lt; len(it.data); cond {\n val = it.data[it.index]\n idx = it.index\n it.index += 1\n }\n return\n }\n\n data := make([]i32, 6)\n for _, i in data {\n data[i] = i32(i*i)\n }\n\n {\n it := make_my_iterator(data)\n for val in my_iterator(&amp;it) {\n fmt.println(val)\n }\n }\n {\n it := make_my_iterator(data)\n for val, idx in my_iterator(&amp;it) {\n fmt.println(val, idx)\n }\n }\n {\n it := make_my_iterator(data)\n for {\n val, _, cond := my_iterator(&amp;it)\n if !cond {\n break\n }\n fmt.println(val)\n }\n }\n}\n\n\nsoa_struct_layout :: proc() {\n fmt.println(&quot;\\n#SOA Struct Layout&quot;)\n\n {\n Vector3 :: struct {x, y, z: f32}\n\n N :: 2\n v_aos: [N]Vector3\n v_aos[0].x = 1\n v_aos[0].y = 4\n v_aos[0].z = 9\n\n fmt.println(len(v_aos))\n fmt.println(v_aos[0])\n fmt.println(v_aos[0].x)\n fmt.println(&amp;v_aos[0].x)\n\n v_aos[1] = {0, 3, 4}\n v_aos[1].x = 2\n fmt.println(v_aos[1])\n fmt.println(v_aos)\n\n v_soa: #soa[N]Vector3\n\n v_soa[0].x = 1\n v_soa[0].y = 4\n v_soa[0].z = 9\n\n\n // Same syntax as AOS and treat as if it was an array\n fmt.println(len(v_soa))\n fmt.println(v_soa[0])\n fmt.println(v_soa[0].x)\n fmt.println(&amp;v_soa[0].x)\n v_soa[1] = {0, 3, 4}\n v_soa[1].x = 2\n fmt.println(v_soa[1])\n\n // Can use SOA syntax if necessary\n v_soa.x[0] = 1\n v_soa.y[0] = 4\n v_soa.z[0] = 9\n fmt.println(v_soa.x[0])\n\n // Same pointer addresses with both syntaxes\n assert(&amp;v_soa[0].x == &amp;v_soa.x[0])\n\n\n // Same fmt printing\n fmt.println(v_aos)\n fmt.println(v_soa)\n }\n {\n // Works with arrays of length &lt;= 4 which have the implicit fields xyzw/rgba\n Vector3 :: distinct [3]f32\n\n N :: 2\n v_aos: [N]Vector3\n v_aos[0].x = 1\n v_aos[0].y = 4\n v_aos[0].z = 9\n\n v_soa: #soa[N]Vector3\n\n v_soa[0].x = 1\n v_soa[0].y = 4\n v_soa[0].z = 9\n }\n {\n // SOA Slices\n // Vector3 :: struct {x, y, z: f32}\n Vector3 :: struct {x: i8, y: i16, z: f32}\n\n N :: 3\n v: #soa[N]Vector3\n v[0].x = 1\n v[0].y = 4\n v[0].z = 9\n\n s: #soa[]Vector3\n s = v[:]\n assert(len(s) == N)\n fmt.println(s)\n fmt.println(s[0].x)\n\n a := s[1:2]\n assert(len(a) == 1)\n fmt.println(a)\n\n d: #soa[dynamic]Vector3\n\n append_soa(&amp;d, Vector3{1, 2, 3}, Vector3{4, 5, 9}, Vector3{-4, -4, 3})\n fmt.println(d)\n fmt.println(len(d))\n fmt.println(cap(d))\n fmt.println(d[:])\n }\n { // soa_zip and soa_unzip\n fmt.println(&quot;\\nsoa_zip and soa_unzip&quot;)\n\n x := []i32{1, 3, 9}\n y := []f32{2, 4, 16}\n z := []b32{true, false, true}\n\n // produce an #soa slice the normal slices passed\n s := soa_zip(a=x, b=y, c=z)\n\n // iterate over the #soa slice\n for v, i in s {\n fmt.println(v, i) // exactly the same as s[i]\n // NOTE: 'v' is NOT a temporary value but has a specialized addressing mode\n // which means that when accessing v.a etc, it does the correct transformation\n // internally:\n // s[i].a === s.a[i]\n fmt.println(v.a, v.b, v.c)\n }\n\n // Recover the slices from the #soa slice\n a, b, c := soa_unzip(s)\n fmt.println(a, b, c)\n }\n}\n\nconstant_literal_expressions :: proc() {\n fmt.println(&quot;\\n#constant literal expressions&quot;)\n\n Bar :: struct {x, y: f32}\n Foo :: struct {a, b: int, using c: Bar}\n\n FOO_CONST :: Foo{b = 2, a = 1, c = {3, 4}}\n\n\n fmt.println(FOO_CONST.a)\n fmt.println(FOO_CONST.b)\n fmt.println(FOO_CONST.c)\n fmt.println(FOO_CONST.c.x)\n fmt.println(FOO_CONST.c.y)\n fmt.println(FOO_CONST.x) // using works as expected\n fmt.println(FOO_CONST.y)\n\n fmt.println(&quot;-------&quot;)\n\n ARRAY_CONST :: [3]int{1 = 4, 2 = 9, 0 = 1}\n\n fmt.println(ARRAY_CONST[0])\n fmt.println(ARRAY_CONST[1])\n fmt.println(ARRAY_CONST[2])\n\n fmt.println(&quot;-------&quot;)\n\n FOO_ARRAY_DEFAULTS :: [3]Foo{{}, {}, {}}\n fmt.println(FOO_ARRAY_DEFAULTS[2].x)\n\n fmt.println(&quot;-------&quot;)\n\n Baz :: enum{A=5, B, C, D}\n ENUM_ARRAY_CONST :: [Baz]int{.A ..= .C = 1, .D = 16}\n\n fmt.println(ENUM_ARRAY_CONST[.A])\n fmt.println(ENUM_ARRAY_CONST[.B])\n fmt.println(ENUM_ARRAY_CONST[.C])\n fmt.println(ENUM_ARRAY_CONST[.D])\n\n fmt.println(&quot;-------&quot;)\n\n Sparse_Baz :: enum{A=5, B, C, D=16}\n #assert(len(Sparse_Baz) &lt; len(#sparse[Sparse_Baz]int))\n SPARSE_ENUM_ARRAY_CONST :: #sparse[Sparse_Baz]int{.A ..= .C = 1, .D = 16}\n\n fmt.println(SPARSE_ENUM_ARRAY_CONST[.A])\n fmt.println(SPARSE_ENUM_ARRAY_CONST[.B])\n fmt.println(SPARSE_ENUM_ARRAY_CONST[.C])\n fmt.println(SPARSE_ENUM_ARRAY_CONST[.D])\n\n fmt.println(&quot;-------&quot;)\n\n\n STRING_CONST :: &quot;Hellope!&quot;\n\n fmt.println(STRING_CONST[0])\n fmt.println(STRING_CONST[2])\n fmt.println(STRING_CONST[3])\n\n fmt.println(STRING_CONST[0:5])\n fmt.println(STRING_CONST[3:][:4])\n}\n\nunion_maybe :: proc() {\n fmt.println(&quot;\\n#union based maybe&quot;)\n\n // NOTE: This is already built-in, and this is just a reimplementation to explain the behaviour\n Maybe :: union($T: typeid) {T}\n\n i: Maybe(u8)\n p: Maybe(^u8) // No tag is stored for pointers, nil is the sentinel value\n\n // Tag size will be as small as needed for the number of variants\n #assert(size_of(i) == size_of(u8) + size_of(u8))\n // No need to store a tag here, the `nil` state is shared with the variant's `nil`\n #assert(size_of(p) == size_of(^u8))\n\n i = 123\n x := i.?\n y, y_ok := p.?\n p = &amp;x\n z, z_ok := p.?\n\n fmt.println(i, p)\n fmt.println(x, &amp;x)\n fmt.println(y, y_ok)\n fmt.println(z, z_ok)\n}\n\ndummy_procedure :: proc() {\n fmt.println(&quot;dummy_procedure&quot;)\n}\n\nexplicit_context_definition :: proc &quot;c&quot; () {\n // Try commenting the following statement out below\n context = runtime.default_context()\n\n fmt.println(&quot;\\n#explicit context definition&quot;)\n dummy_procedure()\n}\n\nrelative_data_types :: proc() {\n fmt.println(&quot;\\n#relative data types&quot;)\n\n x: int = 123\n ptr: #relative(i16) ^int\n ptr = &amp;x\n fmt.println(ptr^)\n\n arr := [3]int{1, 2, 3}\n s := arr[:]\n rel_slice: #relative(i16) []int\n rel_slice = s\n fmt.println(rel_slice)\n fmt.println(rel_slice[:])\n fmt.println(rel_slice[1])\n}\n\nor_else_operator :: proc() {\n fmt.println(&quot;\\n#'or_else'&quot;)\n {\n m: map[string]int\n i: int\n ok: bool\n\n if i, ok = m[&quot;hellope&quot;]; !ok {\n i = 123\n }\n // The above can be mapped to 'or_else'\n i = m[&quot;hellope&quot;] or_else 123\n\n assert(i == 123)\n }\n {\n // 'or_else' can be used with type assertions too, as they\n // have optional ok semantics\n v: union{int, f64}\n i: int\n i = v.(int) or_else 123\n i = v.? or_else 123 // Type inference magic\n assert(i == 123)\n\n m: Maybe(int)\n i = m.? or_else 456\n assert(i == 456)\n }\n}\n\nor_return_operator :: proc() {\n fmt.println(&quot;\\n#'or_return'&quot;)\n // The concept of 'or_return' will work by popping off the end value in a multiple\n // valued expression and checking whether it was not 'nil' or 'false', and if so,\n // set the end return value to value if possible. If the procedure only has one\n // return value, it will do a simple return. If the procedure had multiple return\n // values, 'or_return' will require that all parameters be named so that the end\n // value could be assigned to by name and then an empty return could be called.\n\n Error :: enum {\n None,\n Something_Bad,\n Something_Worse,\n The_Worst,\n Your_Mum,\n }\n\n caller_1 :: proc() -&gt; Error {\n return .None\n }\n\n caller_2 :: proc() -&gt; (int, Error) {\n return 123, .None\n }\n caller_3 :: proc() -&gt; (int, int, Error) {\n return 123, 345, .None\n }\n\n foo_1 :: proc() -&gt; Error {\n // This can be a common idiom in many code bases\n n0, err := caller_2()\n if err != nil {\n return err\n }\n\n // The above idiom can be transformed into the following\n n1 := caller_2() or_return\n\n\n // And if the expression is 1-valued, it can be used like this\n caller_1() or_return\n // which is functionally equivalent to\n if err1 := caller_1(); err1 != nil {\n return err1\n }\n\n // Multiple return values still work with 'or_return' as it only\n // pops off the end value in the multi-valued expression\n n0, n1 = caller_3() or_return\n\n return .None\n }\n foo_2 :: proc() -&gt; (n: int, err: Error) {\n // It is more common that your procedure turns multiple values\n // If 'or_return' is used within a procedure multiple parameters (2+),\n // then all the parameters must be named so that the remaining parameters\n // so that a bare 'return' statement can be used\n\n // This can be a common idiom in many code bases\n x: int\n x, err = caller_2()\n if err != nil {\n return\n }\n\n // The above idiom can be transformed into the following\n y := caller_2() or_return\n _ = y\n\n // And if the expression is 1-valued, it can be used like this\n caller_1() or_return\n\n // which is functionally equivalent to\n if err1 := caller_1(); err1 != nil {\n err = err1\n return\n }\n\n // If using a non-bare 'return' statement is required, setting the return values\n // using the normal idiom is a better choice and clearer to read.\n if z, zerr := caller_2(); zerr != nil {\n return -345 * z, zerr\n }\n\n defer if err != nil {\n fmt.println(&quot;Error in&quot;, #procedure, &quot;:&quot; , err)\n }\n\n n = 123\n return\n }\n\n foo_1()\n foo_2()\n}\n\narbitrary_precision_mathematics :: proc() {\n fmt.println(&quot;\\n# core:math/big&quot;)\n\n print_bigint :: proc(name: string, a: ^big.Int, base := i8(10), print_name := true, newline := true, print_extra_info := true) {\n big.assert_if_nil(a)\n\n as, err := big.itoa(a, base)\n defer delete(as)\n\n cb := big.internal_count_bits(a)\n if print_name {\n fmt.printf(name)\n }\n if err != nil {\n fmt.printf(&quot; (Error: %v) &quot;, err)\n }\n fmt.printf(as)\n if print_extra_info {\n fmt.printf(&quot; (base: %v, bits: %v, digits: %v)&quot;, base, cb, a.used)\n }\n if newline {\n fmt.println()\n }\n }\n\n a, b, c, d, e, f, res := &amp;big.Int{}, &amp;big.Int{}, &amp;big.Int{}, &amp;big.Int{}, &amp;big.Int{}, &amp;big.Int{}, &amp;big.Int{}\n defer big.destroy(a, b, c, d, e, f, res)\n\n // How many bits should the random prime be?\n bits := 64\n // Number of Rabin-Miller trials, -1 for automatic.\n trials := -1\n\n // Default prime generation flags\n flags := big.Primality_Flags{}\n\n err := big.internal_random_prime(a, bits, trials, flags)\n if err != nil {\n fmt.printf(&quot;Error %v while generating random prime.\\n&quot;, err)\n } else {\n print_bigint(&quot;Random Prime A: &quot;, a, 10)\n fmt.printf(&quot;Random number iterations until prime found: %v\\n&quot;, big.RANDOM_PRIME_ITERATIONS_USED)\n }\n\n // If we want to pack this Int into a buffer of u32, how many do we need?\n count := big.internal_int_pack_count(a, u32)\n buf := make([]u32, count)\n defer delete(buf)\n\n written: int\n written, err = big.internal_int_pack(a, buf)\n fmt.printf(&quot;\\nPacked into u32 buf: %v | err: %v | written: %v\\n&quot;, buf, err, written)\n\n // If we want to pack this Int into a buffer of bytes of which only the bottom 6 bits are used, how many do we need?\n nails := 2\n\n count = big.internal_int_pack_count(a, u8, nails)\n byte_buf := make([]u8, count)\n defer delete(byte_buf)\n\n written, err = big.internal_int_pack(a, byte_buf, nails)\n fmt.printf(&quot;\\nPacked into buf of 6-bit bytes: %v | err: %v | written: %v\\n&quot;, byte_buf, err, written)\n\n\n\n // Pick another random big Int, not necesssarily prime.\n err = big.random(b, 2048)\n print_bigint(&quot;\\n2048 bit random number: &quot;, b)\n\n // Calculate GCD + LCM in one fell swoop\n big.gcd_lcm(c, d, a, b)\n\n print_bigint(&quot;\\nGCD of random prime A and random number B: &quot;, c)\n print_bigint(&quot;\\nLCM of random prime A and random number B (in base 36): &quot;, d, 36)\n}\n\nmatrix_type :: proc() {\n fmt.println(&quot;\\n# matrix type&quot;)\n // A matrix is a mathematical type built into Odin. It is a regular array of numbers,\n // arranged in rows and columns\n \n {\n // The following represents a matrix that has 2 rows and 3 columns\n m: matrix[2, 3]f32\n \n m = matrix[2, 3]f32{\n 1, 9, -13,\n 20, 5, -6,\n }\n \n // Element types of integers, float, and complex numbers are supported by matrices.\n // There is no support for booleans, quaternions, or any compound type.\n \n // Indexing a matrix can be used with the matrix indexing syntax\n // This mirrors othe type usages: type on the left, usage on the right\n \n elem := m[1, 2] // row 1, column 2\n assert(elem == -6)\n \n \n // Scalars act as if they are scaled identity matrices\n // and can be assigned to matrices as them\n b := matrix[2, 2]f32{}\n f := f32(3)\n b = f\n \n fmt.println(&quot;b&quot;, b)\n fmt.println(&quot;b == f&quot;, b == f)\n \n } \n \n { // Matrices support multiplication between matrices\n a := matrix[2, 3]f32{\n 2, 3, 1,\n 4, 5, 0,\n }\n \n b := matrix[3, 2]f32{\n 1, 2,\n 3, 4,\n 5, 6,\n }\n \n fmt.println(&quot;a&quot;, a)\n fmt.println(&quot;b&quot;, b)\n \n c := a * b\n #assert(type_of(c) == matrix[2, 2]f32)\n fmt.tprintln(&quot;c = a * b&quot;, c) \n }\n \n { // Matrices support multiplication between matrices and arrays\n m := matrix[4, 4]f32{\n 1, 2, 3, 4, \n 5, 5, 4, 2, \n 0, 1, 3, 0, \n 0, 1, 4, 1,\n }\n \n v := [4]f32{1, 5, 4, 3}\n \n // treating 'v' as a column vector\n fmt.println(&quot;m * v&quot;, m * v)\n \n // treating 'v' as a row vector\n fmt.println(&quot;v * m&quot;, v * m)\n \n // Support with non-square matrices\n s := matrix[2, 4]f32{ // [4][2]f32\n 2, 4, 3, 1, \n 7, 8, 6, 5, \n }\n \n w := [2]f32{1, 2}\n r: [4]f32 = w * s\n fmt.println(&quot;r&quot;, r)\n }\n \n { // Component-wise operations \n // if the element type supports it\n // Not support for '/', '%', or '%%' operations\n \n a := matrix[2, 2]i32{\n 1, 2,\n 3, 4,\n }\n \n b := matrix[2, 2]i32{\n -5, 1,\n 9, -7,\n }\n \n c0 := a + b\n c1 := a - b\n c2 := a &amp; b\n c3 := a | b\n c4 := a ~ b\n c5 := a &amp;~ b\n\n // component-wise multiplication\n // since a * b would be a standard matrix multiplication\n c6 := hadamard_product(a, b) \n \n \n fmt.println(&quot;a + b&quot;, c0)\n fmt.println(&quot;a - b&quot;, c1)\n fmt.println(&quot;a &amp; b&quot;, c2)\n fmt.println(&quot;a | b&quot;, c3)\n fmt.println(&quot;a ~ b&quot;, c4)\n fmt.println(&quot;a &amp;~ b&quot;, c5)\n fmt.println(&quot;hadamard_product(a, b)&quot;, c6)\n }\n \n { // Submatrix casting square matrices\n // Casting a square matrix to another square matrix with same element type\n // is supported. \n // If the cast is to a smaller matrix type, the top-left submatrix is taken.\n // If the cast is to a larger matrix type, the matrix is extended with zeros\n // everywhere and ones in the diagonal for the unfilled elements of the \n // extended matrix.\n \n mat2 :: distinct matrix[2, 2]f32\n mat4 :: distinct matrix[4, 4]f32\n \n m2 := mat2{\n 1, 3,\n 2, 4,\n }\n \n m4 := mat4(m2)\n assert(m4[2, 2] == 1)\n assert(m4[3, 3] == 1)\n fmt.printf(&quot;m2 %#v\\n&quot;, m2)\n fmt.println(&quot;m4&quot;, m4)\n fmt.println(&quot;mat2(m4)&quot;, mat2(m4))\n assert(mat2(m4) == m2)\n \n b4 := mat4{\n 1, 2, 0, 0,\n 3, 4, 0, 0,\n 5, 0, 6, 0,\n 0, 7, 0, 8,\n }\n fmt.println(&quot;b4&quot;, matrix_flatten(b4))\n }\n \n { // Casting non-square matrices\n // Casting a matrix to another matrix is allowed as long as they share \n // the same element type and the number of elements (rows*columns).\n // Matrices in Odin are stored in column-major order, which means\n // the casts will preserve this element order.\n \n mat2x4 :: distinct matrix[2, 4]f32\n mat4x2 :: distinct matrix[4, 2]f32\n \n x := mat2x4{\n 1, 3, 5, 7, \n 2, 4, 6, 8,\n }\n \n y := mat4x2(x)\n fmt.println(&quot;x&quot;, x)\n fmt.println(&quot;y&quot;, y)\n }\n \n // TECHNICAL INFORMATION: the internal representation of a matrix in Odin is stored\n // in column-major format\n // e.g. matrix[2, 3]f32 is internally [3][2]f32 (with different a alignment requirement)\n // Column-major is used in order to utilize (SIMD) vector instructions effectively on \n // modern hardware, if possible.\n //\n // Unlike normal arrays, matrices try to maximize alignment to allow for the (SIMD) vectorization\n // properties whilst keeping zero padding (either between columns or at the end of the type).\n // \n // Zero padding is a compromise for use with third-party libraries, instead of optimizing for performance.\n // Padding between columns was not taken even if that would have allowed each column to be loaded \n // individually into a SIMD register with the correct alignment properties. \n // \n // Currently, matrices are limited to a maximum of 16 elements (rows*columns), and a minimum of 1 element.\n // This is because matrices are stored as values (not a reference type), and thus operations on them will\n // be stored on the stack. Restricting the maximum element count minimizing the possibility of stack overflows.\n \n // Built-in Procedures (Compiler Level)\n // transpose(m)\n // transposes a matrix\n // outer_product(a, b)\n // takes two array-like data types and returns the outer product\n // of the values in a matrix\n // hadamard_product(a, b)\n // component-wise multiplication of two matrices of the same type\n // matrix_flatten(m)\n // converts the matrix into a flatten array of elements\n // in column-major order\n // Example:\n // m := matrix[2, 2]f32{\n // x0, x1,\n // y0, y1, \n // }\n // array: [4]f32 = matrix_flatten(m)\n // assert(array == {x0, y0, x1, y1})\n // conj(x)\n // conjugates the elements of a matrix for complex element types only\n \n // Built-in Procedures (Runtime Level) (all square matrix procedures)\n // determinant(m)\n // adjugate(m)\n // inverse(m)\n // inverse_transpose(m)\n // hermitian_adjoint(m)\n // matrix_trace(m)\n // matrix_minor(m)\n}\n\nmain :: proc() {\n /*\n For More Odin Examples - https://github.com/odin-lang/examples\n This repository contains examples of how certain things can be accomplished \n in idiomatic Odin, allowing you learn its semantics, as well as how to use \n parts of the core and vendor package collections.\n */\n\n when true {\n the_basics()\n control_flow()\n named_proc_return_parameters()\n explicit_procedure_overloading()\n struct_type()\n union_type()\n using_statement()\n implicit_context_system()\n parametric_polymorphism()\n array_programming()\n map_type()\n implicit_selector_expression()\n partial_switch()\n cstring_example()\n bit_set_type()\n deferred_procedure_associations()\n reflection()\n quaternions()\n unroll_for_statement()\n where_clauses()\n foreign_system()\n ranged_fields_for_array_compound_literals()\n deprecated_attribute()\n range_statements_with_multiple_return_values()\n threading_example()\n soa_struct_layout()\n constant_literal_expressions()\n union_maybe()\n explicit_context_definition()\n relative_data_types()\n or_else_operator()\n or_return_operator()\n arbitrary_precision_mathematics()\n matrix_type()\n }\n}\n\n</code></pre>\n","relevance":1083,"illegal":false,"_emitter":"{\n \"children\": [\n \"
\",\n        {\n            \"children\": [\n                \"package\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" main\\n\\n\",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "core:fmt"\\n\",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "core:mem"\\n\",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "core:os"\\n\",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "core:thread"\\n\",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "core:time"\\n\",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "core:reflect"\\n\",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "core:runtime"\\n\",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "core:intrinsics"\\n\",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "core:math/big"\\n\\n\",\n        {\n            \"children\": [\n                \"/*\\n\",\n                \"    Odin is a \",\n                \"general-purpose\",\n                \" programming language with \",\n                \"distinct typing built\\n    for high performance,\",\n                \" modern systems and \",\n                \"data-oriented programming.\\n\\n\",\n                \"    Odin is the \",\n                \"C\",\n                \" alternative for the \",\n                \"Joy of Programming.\\n\\n    # Installing Odin\\n    Getting Started - https://odin-lang.org/docs/install/\\n\",\n                \"        Instructions for downloading \",\n                \"and\",\n                \" install the Odin \",\n                \"compiler and libraries.\\n\\n    # Learning Odin\\n    Getting Started - https://odin-lang.org/docs/install/\\n\",\n                \"        Getting Started with \",\n                \"Odin. Downloading, installing, and getting your\\n\",\n                \"        first program to \",\n                \"compile and run.\\n    Overview of Odin - https://odin-lang.org/docs/overview/\\n        An overview of\",\n                \" the Odin programming \",\n                \"language and its features.\\n\",\n                \"    Frequently Asked Questions \",\n                \"(FAQ) - https://odin-lang.org/docs/faq/\\n\",\n                \"        Answers to common \",\n                \"questions about Odin.\\n    Packages - https://pkg.odin-lang.org/\\n\",\n                \"        Documentation for all \",\n                \"the\",\n                \" official packages part \",\n                \"of the\\n\",\n                \"        core and vendor \",\n                \"library collections.\\n    Nightly Builds - https://odin-lang.org/docs/nightly/\\n\",\n                \"        Get the latest \",\n                \"nightly builds of Odin.\\n\",\n                \"    More Odin Examples \",\n                \"- https://github.com/odin-lang/examples\\n\",\n                \"        This repository contains \",\n                \"examples of\",\n                \" how certain things \",\n                \"can be accomplished \\n        in idiomatic Odin,\",\n                \" allowing you learn \",\n                \"its semantics, as well as\",\n                \" how to use \",\n                \"\\n        parts of\",\n                \" the core and \",\n                \"vendor package collections.\\n*/\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\nthe_basics :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# the basics")\\n\\n    { \",\n        {\n            \"children\": [\n                \"// The Basics\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println("Hellope")\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Lexical elements and \",\n                \"literals\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// A comment\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        my_integer_variable: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// A comment for documentaton\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Multi-line comments begin \",\n                \"with /*\",\n                \" and end with \",\n                \"*/. Multi-line comments can\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// also be nested (unlike in C):\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"/*\\n\",\n                \"            You can have \",\n                \"any text or code here and\\n            have it be commented.\\n            /*\\n                \",\n                {\n                    \"children\": [\n                        \"NOTE:\"\n                    ],\n                    \"scope\": \"doctag\"\n                },\n                \" comments can be nested!\\n            */\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        */\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" String literals are \",\n                \"enclosed\",\n                \" in double quotes \",\n                \"and\",\n                \" character literals in \",\n                \"single quotes.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Special characters are \",\n                \"escaped\",\n                \" with a backslash \",\n                \"\\\\\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        some_string := "This is a \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \""\\n        _ = \",\n        {\n            \"children\": [\n                \"'A'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// unicode codepoint literal\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        _ = \",\n        {\n            \"children\": [\n                \"'\",\n                \"\\\\n\",\n                \"'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"\\n        _ = "C:\\\\\\\\Windows\\\\\\\\notepad.exe"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Raw string literals \",\n                \"are\",\n                \" enclosed with single \",\n                \"back ticks\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        _ = \",\n        {\n            \"children\": [\n                \"`C:\\\\Windows\\\\notepad.exe`\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// The length of\",\n                \" a string in \",\n                \"bytes can be\",\n                \" found using the \",\n                \"built-in `len` procedure:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        _ = len("Foo")\\n        _ = len(some_string)\\n\\n\\n        \",\n        {\n            \"children\": [\n                \"// Numbers\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Numerical literals are \",\n                \"written\",\n                \" similar to most \",\n                \"other programming languages.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// A\",\n                \" useful feature in \",\n                \"Odin\",\n                \" is that underscores \",\n                \"are allowed for better\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// readability: 1_000_000_000 (one billion). A\",\n                \" number that contains \",\n                \"a dot is a\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" floating point literal: \",\n                \"1.0e9 (one billion). If\",\n                \" a number literal \",\n                \"is suffixed\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// with i, is an\",\n                \" imaginary number literal: \",\n                \"2i (2\",\n                \" multiply the square \",\n                \"root of -1).\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Binary literals are \",\n                \"prefixed with 0b,\",\n                \" octal literals with \",\n                \"0o, and hexadecimal\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// literals 0x. A\",\n                \" leading zero does \",\n                \"not produce an octal constant (unlike C).\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// In Odin,\",\n                \" if a numeric \",\n                \"constant can be represented by a type without\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// precision loss,\",\n                \" it will automatically \",\n                \"convert to that type.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        x: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"1.0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// A\",\n                \" float literal but \",\n                \"it can be represented by an\",\n                \" integer without precision \",\n                \"loss\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Constant literals are \",\n                \"“untyped”\",\n                \" which means that \",\n                \"they\",\n                \" can implicitly convert \",\n                \"to a type.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        y: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// `y` is typed of type `int`\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        y = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"  \",\n        {\n            \"children\": [\n                \"// `1` is an\",\n                \" untyped integer literal \",\n                \"which\",\n                \" can implicitly convert \",\n                \"to `int`\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        z: \",\n        {\n            \"children\": [\n                \"f64\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// `z` is typed of type `f64` (64-bit floating point number)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        z = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"  \",\n        {\n            \"children\": [\n                \"// `1` is an\",\n                \" untyped integer literal \",\n                \"which can be\",\n                \" implicitly converted to \",\n                \"`f64`\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n                \",\n        {\n            \"children\": [\n                \"// No\",\n                \" need for any \",\n                \"suffixes or\",\n                \" decimal places like \",\n                \"in other languages\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n                \",\n        {\n            \"children\": [\n                \"// (with the exception of negative zero, which must be given as `-0.0`)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n                \",\n        {\n            \"children\": [\n                \"// CONSTANTS JUST WORK!!!\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n\\n        \",\n        {\n            \"children\": [\n                \"// Assignment statements\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        h: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"//\",\n                \" declares a new \",\n                \"variable `h` with type `int`\",\n                \" and assigns a \",\n                \"value to it\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        h = \",\n        {\n            \"children\": [\n                \"637\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"//\",\n                \" assigns a new \",\n                \"value to `h`\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// `=`\",\n                \" is the assignment \",\n                \"operator\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" You can assign \",\n                \"multiple variables with it:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        a, b := \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", "hello" \",\n        {\n            \"children\": [\n                \"// declares `a` and `b`\",\n                \" and infers the \",\n                \"types from the assignments\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        b, a = "\",\n        {\n            \"children\": [\n                \"byte\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// Note: `:=` is two tokens, `:` and `=`.\",\n                \" The following are \",\n                \"equivalent,\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"/*\\n            i: int = 123\\n            i:     = 123\\n            i := 123\\n        */\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// Constant declarations\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Constants are entities \",\n                \"(symbols) which have an assigned value.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// The constant’s value cannot be changed.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// The constant’s value must be able to be\",\n                \" evaluated at compile \",\n                \"time:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        X :: "what" \",\n        {\n            \"children\": [\n                \"// constant `X`\",\n                \" has the untyped \",\n                \"string value "what"\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// Constants can be\",\n                \" explicitly typed like \",\n                \"a variable declaration:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        Y : \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" : \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        Z :: Y + \",\n        {\n            \"children\": [\n                \"7\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"//\",\n                \" constant computations are \",\n                \"possible\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        _ = my_integer_variable\\n        _ = x\\n    }\\n}\\n\\ncontrol_flow :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# control flow")\\n    { \",\n        {\n            \"children\": [\n                \"// Control flow\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// For loop\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Odin has only \",\n                \"one loop statement, the `for` loop\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// Basic for loop\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i := \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; i < \",\n        {\n            \"children\": [\n                \"10\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; i += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println(i)\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// \",\n                {\n                    \"children\": [\n                        \"NOTE:\"\n                    ],\n                    \"scope\": \"doctag\"\n                },\n                \" Unlike other languages \",\n                \"like C, there are no parentheses `( )`\",\n                \" surrounding the three \",\n                \"components.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// Braces `{ }` or a `do` are always required\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i := \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; i < \",\n        {\n            \"children\": [\n                \"10\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; i += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" { }\\n        \",\n        {\n            \"children\": [\n                \"// for i := 0; i < 10; i += 1 do fmt.print()\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The initial and \",\n                \"post statements are optional\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        i := \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" ; i < \",\n        {\n            \"children\": [\n                \"10\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; {\\n            i += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" These semicolons can \",\n                \"be dropped. This `for`\",\n                \" loop is equivalent \",\n                \"to C's `while` loop\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        i = \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i < \",\n        {\n            \"children\": [\n                \"10\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            i += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// If\",\n                \" the condition is \",\n                \"omitted, an\",\n                \" infinite loop is \",\n                \"produced:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"break\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// Range-based for loop\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The basic for \",\n                \"loop\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" j := \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; j < \",\n        {\n            \"children\": [\n                \"10\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; j += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println(j)\\n        }\\n        \",\n        {\n            \"children\": [\n                \"// can also be written\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" j \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"10\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println(j)\\n        }\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" j \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".=\",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println(j)\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Certain built-in types \",\n                \"can be iterated over\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        some_string := "Hello, 世界"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" character \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_string { \",\n        {\n            \"children\": [\n                \"//\",\n                \" Strings are assumed \",\n                \"to be UTF-8\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            fmt.println(character)\\n        }\\n\\n        some_array := [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" value \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_array {\\n            fmt.println(value)\\n        }\\n\\n        some_slice := []\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" value \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_slice {\\n            fmt.println(value)\\n        }\\n\\n        some_dynamic_array := [\",\n        {\n            \"children\": [\n                \"dynamic\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" delete(some_dynamic_array)\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" value \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_dynamic_array {\\n            fmt.println(value)\\n        }\\n\\n\\n        some_map := \",\n        {\n            \"children\": [\n                \"map\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"[\",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{"A" = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", "C" = \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", "B" = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" delete(some_map)\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" key \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_map {\\n            fmt.println(key)\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Alternatively a second \",\n                \"index value can be added\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" character, index \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_string {\\n            fmt.println(index, character)\\n        }\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" value, index \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_array {\\n            fmt.println(index, value)\\n        }\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" value, index \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_slice {\\n            fmt.println(index, value)\\n        }\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" value, index \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_dynamic_array {\\n            fmt.println(index, value)\\n        }\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" key, value \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_map {\\n            fmt.println(key, value)\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The iterated values \",\n                \"are\",\n                \" copies and cannot \",\n                \"be written to.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The following idiom \",\n                \"is\",\n                \" useful for iterating \",\n                \"over\",\n                \" a container in \",\n                \"a by-reference manner:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" _, idx \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" some_slice {\\n            some_slice[idx] = (idx+\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")*(idx+\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        }\\n\\n\\n        \",\n        {\n            \"children\": [\n                \"// If statements\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        x := \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x >= \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println("x is positive")\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" y := -\",\n        {\n            \"children\": [\n                \"34\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; y < \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println("y is negative")\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" y := \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; y < \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println("y is negative")\\n        } \",\n        {\n            \"children\": [\n                \"else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" y == \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println("y is zero")\\n        } \",\n        {\n            \"children\": [\n                \"else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            fmt.println("y is positive")\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// Switch statement\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// A\",\n                \" switch statement is \",\n                \"another\",\n                \" way to write \",\n                \"a sequence of if-else statements.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// In Odin,\",\n                \" the default case \",\n                \"is denoted as\",\n                \" a case without \",\n                \"any expression.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        #partial \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" arch := ODIN_ARCH; arch {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .i386:\\n            fmt.println("\",\n        {\n            \"children\": [\n                \"32\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"-bit")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .amd64:\\n            fmt.println("\",\n        {\n            \"children\": [\n                \"64\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"-bit")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \": \",\n        {\n            \"children\": [\n                \"// default\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            fmt.println("Unsupported architecture")\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// Odin’s `switch`\",\n                \" is like one \",\n                \"in C or C++,\",\n                \" except that Odin \",\n                \"only\",\n                \" runs the selected \",\n                \"case.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" This means that \",\n                \"a `break`\",\n                \" statement is not \",\n                \"needed\",\n                \" at the end \",\n                \"of each case.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Another important difference \",\n                \"is\",\n                \" that the case \",\n                \"values need not be integers nor constants.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// To\",\n                \" achieve a C-like \",\n                \"fall\",\n                \" through into the \",\n                \"next case block, the keyword `fallthrough` can be used.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        one_angry_dwarf :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n            fmt.println("one_angry_dwarf was called")\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" j := \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; j {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" one_angry_dwarf():\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// A\",\n                \" switch statement without \",\n                \"a\",\n                \" condition is the \",\n                \"same as `switch true`.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// This can be\",\n                \" used to write \",\n                \"a\",\n                \" clean and long \",\n                \"if-else\",\n                \" chain and have \",\n                \"the\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" ability to break \",\n                \"if needed\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x < \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\\n            fmt.println("x is negative")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x == \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\\n            fmt.println("x is zero")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \":\\n            fmt.println("x is positive")\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// A `switch`\",\n                \" statement can also \",\n                \"use\",\n                \" ranges like a \",\n                \"range-based loop:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" c := \",\n        {\n            \"children\": [\n                \"'j'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"; c {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"'A'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"..=\",\n        {\n            \"children\": [\n                \"'Z'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"'a'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"..=\",\n        {\n            \"children\": [\n                \"'z'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"'0'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"..=\",\n        {\n            \"children\": [\n                \"'9'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \":\\n            fmt.println("c is alphanumeric")\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"10\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\\n            fmt.println("units")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"10.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"13\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\\n            fmt.println("pre-teens")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"13.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"20\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\\n            fmt.println("teens")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"20.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"30\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\\n            fmt.println("twenties")\\n        }\\n    }\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Defer statement\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// A\",\n                \" defer statement defers \",\n                \"the execution of\",\n                \" a statement until \",\n                \"the end of\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" the scope it \",\n                \"is in.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The following will \",\n                \"print 4 then 234:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        {\\n            x := \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" fmt.println(x)\\n            {\\n                \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n                x = \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n            }\\n            fmt.println(x)\\n\\n            x = \",\n        {\n            \"children\": [\n                \"234\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" You can defer \",\n                \"an entire block too:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        {\\n            bar :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {}\\n\\n            \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n                fmt.println("\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"")\\n                fmt.println("\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"")\\n            }\\n\\n            cond := \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" cond {\\n                bar()\\n            }\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Defer statements are \",\n                \"executed\",\n                \" in the reverse \",\n                \"order\",\n                \" that they were \",\n                \"declared:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        {\\n            \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" fmt.println("\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"")\\n            \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" fmt.println("\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"")\\n            \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" fmt.println("\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"")\\n        }\\n        \",\n        {\n            \"children\": [\n                \"// Will print 3, 2, and then 1.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n            f, err := os.open("my_file.txt")\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err != \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n                \",\n        {\n            \"children\": [\n                \"// handle error\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            }\\n            \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" os.close(f)\\n            \",\n        {\n            \"children\": [\n                \"// rest of code\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        }\\n    }\\n\\n    { \",\n        {\n            \"children\": [\n                \"// When statement\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"/*\\n\",\n                \"            The when statement \",\n                \"is\",\n                \" almost identical to \",\n                \"the\",\n                \" if statement but \",\n                \"with some differences:\\n\\n            *\",\n                \" Each condition must \",\n                \"be\",\n                \" a constant expression \",\n                \"as a when\\n\",\n                \"              statement is evaluated \",\n                \"at compile time.\\n            *\",\n                \" The statements within \",\n                \"a branch do\",\n                \" not create a \",\n                \"new scope\\n            *\",\n                \" The compiler checks \",\n                \"the\",\n                \" semantics and code \",\n                \"only for statements\\n\",\n                \"              that belong to \",\n                \"the\",\n                \" first condition that \",\n                \"is true\\n            * An\",\n                \" initial statement is \",\n                \"not\",\n                \" allowed in a \",\n                \"when statement\\n            *\",\n                \" when statements are \",\n                \"allowed at file scope\\n        */\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// Example\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"when\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" ODIN_ARCH == .i386 {\\n            fmt.println("\",\n        {\n            \"children\": [\n                \"32\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" bit")\\n        } \",\n        {\n            \"children\": [\n                \"else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"when\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" ODIN_ARCH == .amd64 {\\n            fmt.println("\",\n        {\n            \"children\": [\n                \"64\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" bit")\\n        } \",\n        {\n            \"children\": [\n                \"else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            fmt.println("Unknown architecture")\\n        }\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The when statement \",\n                \"is\",\n                \" very useful for \",\n                \"writing platform specific code.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" This is akin \",\n                \"to the #if construct in C’s preprocessor however, in Odin,\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" it is type \",\n                \"checked.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Branch statements\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        cond, cond1, cond2 := \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n        one_step :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() { fmt.println("one_step") }\\n        beyond :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() { fmt.println("beyond") }\\n\\n        \",\n        {\n            \"children\": [\n                \"// Break statement\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" cond {\\n            \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \":\\n                \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" cond {\\n                    \",\n        {\n            \"children\": [\n                \"break\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// break out of the `switch` statement\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n                }\\n            }\\n\\n            \",\n        {\n            \"children\": [\n                \"break\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// break out of the `for` statement\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        }\\n\\n        loop: \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" cond1 {\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" cond2 {\\n                \",\n        {\n            \"children\": [\n                \"break\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" loop \",\n        {\n            \"children\": [\n                \"// leaves both loops\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            }\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// Continue statement\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" cond {\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" cond2 {\\n                \",\n        {\n            \"children\": [\n                \"continue\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n            }\\n            fmt.println("Hellope")\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// Fallthrough statement\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// Odin’s\",\n                \" switch is like \",\n                \"one in C or C++,\",\n                \" except that Odin \",\n                \"only runs the selected\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" case. This means \",\n                \"that\",\n                \" a break statement \",\n                \"is\",\n                \" not needed at \",\n                \"the end of each case.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Another important difference \",\n                \"is\",\n                \" that the case \",\n                \"values need not be integers nor\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// constants.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// fallthrough can be\",\n                \" used to explicitly \",\n                \"fall\",\n                \" through into the \",\n                \"next case block:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i := \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; i {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\\n            one_step()\\n            \",\n        {\n            \"children\": [\n                \"fallthrough\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\\n            beyond()\\n        }\\n    }\\n}\\n\\n\\nnamed_proc_return_parameters :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# named \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" parameters")\\n\\n    foo0 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    }\\n    foo1 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> (a: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") {\\n        a = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n    }\\n    foo2 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> (a, b: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") {\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Named return values \",\n                \"act\",\n                \" like variables within \",\n                \"the scope\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        a = \",\n        {\n            \"children\": [\n                \"321\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        b = \",\n        {\n            \"children\": [\n                \"567\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" b, a\\n    }\\n    fmt.println("foo0 =", foo0()) \",\n        {\n            \"children\": [\n                \"// 123\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    fmt.println("foo1 =", foo1()) \",\n        {\n            \"children\": [\n                \"// 123\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    fmt.println("foo2 =", foo2()) \",\n        {\n            \"children\": [\n                \"// 567 321\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n}\\n\\n\\nexplicit_procedure_overloading :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# explicit procedure overloading")\\n\\n    add_ints :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a, b: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n        x := a + b\\n        fmt.println("add_ints", x)\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x\\n    }\\n    add_floats :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a, b: \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n        x := a + b\\n        fmt.println("add_floats", x)\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x\\n    }\\n    add_numbers :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", b: \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", c: \",\n        {\n            \"children\": [\n                \"u8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n        x := \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(a) + \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(b) + \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(c)\\n        fmt.println("add_numbers", x)\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x\\n    }\\n\\n    add :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"{add_ints, add_floats, add_numbers}\\n\\n    add(\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"), \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"))\\n    add(\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"), \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"))\\n    add(\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"), \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"), \",\n        {\n            \"children\": [\n                \"u8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"))\\n\\n    add(\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")     \",\n        {\n            \"children\": [\n                \"//\",\n                \" untyped ints coerce \",\n                \"to\",\n                \" int tighter than \",\n                \"f32\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    add(\",\n        {\n            \"children\": [\n                \"1.0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2.0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \") \",\n        {\n            \"children\": [\n                \"//\",\n                \" untyped floats coerce \",\n                \"to f32 tighter than int\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    add(\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")  \",\n        {\n            \"children\": [\n                \"// three parameters\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n    \",\n        {\n            \"children\": [\n                \"// Ambiguous answers\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// add(1.0, 2)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// add(1, 2.0)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n}\\n\\nstruct_type :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" type")\\n    \",\n        {\n            \"children\": [\n                \"// A\",\n                \" struct is a \",\n                \"record\",\n                \" type in Odin. \",\n                \"It\",\n                \" is a collection \",\n                \"of fields.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" Struct fields are \",\n                \"accessed by using a dot:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    {\\n        Vector2 :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            x: \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n            y: \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n        }\\n        v := Vector2{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        v.x = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        fmt.println(v.x)\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Struct fields can \",\n                \"be\",\n                \" accessed through a \",\n                \"struct pointer:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        v = Vector2{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        p := &v\\n        p.x = \",\n        {\n            \"children\": [\n                \"1335\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        fmt.println(v)\\n\\n        \",\n        {\n            \"children\": [\n                \"// We could write p^.x, however,\",\n                \" it is to \",\n                \"nice abstract the ability\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" to not explicitly \",\n                \"dereference\",\n                \" the pointer. This \",\n                \"is very useful when\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" refactoring code to \",\n                \"use\",\n                \" a pointer rather \",\n                \"than a value, and vice versa.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n    {\\n        \",\n        {\n            \"children\": [\n                \"// A\",\n                \" struct literal can \",\n                \"be denoted by providing the struct’s type\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// followed by {}. A\",\n                \" struct literal must \",\n                \"either provide all the\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// arguments or none:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        Vector3 :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            x, y, z: \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n        }\\n        v: Vector3\\n        v = Vector3{} \",\n        {\n            \"children\": [\n                \"// Zero value\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        v = Vector3{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" You can list \",\n                \"just a subset of\",\n                \" the fields if \",\n                \"you specify the\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// field by name (the order of\",\n                \" the named fields \",\n                \"does not matter):\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        v = Vector3{z=\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", y=\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        assert(v.x == \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        assert(v.y == \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        assert(v.z == \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n    }\\n    {\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Structs can tagged \",\n                \"with\",\n                \" different memory layout \",\n                \"and alignment requirements:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        a :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" #align \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"   {} \",\n        {\n            \"children\": [\n                \"// align to 4 bytes\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        b :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" #packed    {} \",\n        {\n            \"children\": [\n                \"//\",\n                \" remove padding between \",\n                \"fields\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        c :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" #raw_union {} \",\n        {\n            \"children\": [\n                \"//\",\n                \" all fields share \",\n                \"the same offset (0).\",\n                \" This is the \",\n                \"same as C's union\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n\\n}\\n\\n\\nunion_type :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# \",\n        {\n            \"children\": [\n                \"union\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" type")\\n    {\\n        val: \",\n        {\n            \"children\": [\n                \"union\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"}\\n        val = \",\n        {\n            \"children\": [\n                \"137\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i, ok := val.(\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"); ok {\\n            fmt.println(i)\\n        }\\n        val = \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n        fmt.println(val)\\n\\n        val = \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" v \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" val {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \":  fmt.println("\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"",  v)\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \": fmt.println("\",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"", v)\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \":      fmt.println("\",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"")\\n        }\\n    }\\n    {\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" There is a \",\n                \"duality between `any` and `union`\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// An `any`\",\n                \" has a pointer \",\n                \"to\",\n                \" the data and \",\n                \"allows\",\n                \" for any type \",\n                \"(open)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// A `union` has as\",\n                \" binary blob to \",\n                \"store\",\n                \" the data and \",\n                \"allows\",\n                \" only certain types \",\n                \"(closed)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The following code \",\n                \"is with `any`\",\n                \" but has the \",\n                \"same syntax\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        val: \",\n        {\n            \"children\": [\n                \"any\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        val = \",\n        {\n            \"children\": [\n                \"137\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i, ok := val.(\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"); ok {\\n            fmt.println(i)\\n        }\\n        val = \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n        fmt.println(val)\\n\\n        val = \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" v \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" val {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \":  fmt.println("\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"",  v)\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \": fmt.println("\",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"", v)\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \":      fmt.println("\",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"")\\n        }\\n    }\\n\\n    Vector3 :: \",\n        {\n            \"children\": [\n                \"distinct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n    Quaternion :: \",\n        {\n            \"children\": [\n                \"distinct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"quaternion128\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n\\n    \",\n        {\n            \"children\": [\n                \"// More realistic examples\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    {\\n        \",\n        {\n            \"children\": [\n                \"// NOTE(bill):\",\n                \" For the above \",\n                \"basic examples,\",\n                \" you may not \",\n                \"have any\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" particular use for \",\n                \"it. However, my\",\n                \" main use for \",\n                \"them\",\n                \" is not for \",\n                \"these\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// simple cases. My\",\n                \" main use is \",\n                \"for\",\n                \" hierarchical types. Many \",\n                \"prefer\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// subtyping,\",\n                \" embedding the base \",\n                \"data\",\n                \" into the derived \",\n                \"types. Below is\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// an example of\",\n                \" this for a \",\n                \"basic game Entity.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        Entity :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            id:          \",\n        {\n            \"children\": [\n                \"u64\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n            name:        \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n            position:    Vector3,\\n            orientation: Quaternion,\\n\\n            derived: \",\n        {\n            \"children\": [\n                \"any\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n        }\\n\\n        Frog :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"using\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" entity: Entity,\\n            jump_height:  \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n        }\\n\\n        Monster :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"using\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" entity: Entity,\\n            is_robot:     \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n            is_zombie:    \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// See `parametric_polymorphism` procedure for details\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        new_entity :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"($T: \",\n        {\n            \"children\": [\n                \"typeid\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \") -> ^Entity {\\n            t := new(T)\\n            t.derived = t^\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" t\\n        }\\n\\n        entity := new_entity(Monster)\\n\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" e \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" entity.derived {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" Frog:\\n            fmt.println("Ribbit")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" Monster:\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" e.is_robot  { fmt.println("Robotic") }\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" e.is_zombie { fmt.println("Grrrr!")  }\\n            fmt.println("I\",\n        {\n            \"children\": [\n                \"'m a monster")\\n        }\\n    }\\n\\n    {\\n        // NOTE(bill): A union can be used to achieve something similar. Instead\\n        // of embedding the base data into the derived types, the derived data\\n        // in embedded into the base type. Below is the same example of the\\n        // basic game Entity but using an union.\\n\\n        Entity :: struct {\\n            id:          u64,\\n            name:        string,\\n            position:    Vector3,\\n            orientation: Quaternion,\\n\\n            derived: union {Frog, Monster},\\n        }\\n\\n        Frog :: struct {\\n            using entity: ^Entity,\\n            jump_height:  f32,\\n        }\\n\\n        Monster :: struct {\\n            using entity: ^Entity,\\n            is_robot:     bool,\\n            is_zombie:    bool,\\n        }\\n\\n        // See `parametric_polymorphism` procedure for details\\n        new_entity :: proc($T: typeid) -> ^Entity {\\n            t := new(Entity)\\n            t.derived = T{entity = t}\\n            return t\\n        }\\n\\n        entity := new_entity(Monster)\\n\\n        switch e in entity.derived {\\n        case Frog:\\n            fmt.println("Ribbit")\\n        case Monster:\\n            if e.is_robot  { fmt.println("Robotic") }\\n            if e.is_zombie { fmt.println("Grrrr!")  }\\n        }\\n\\n        // NOTE(bill): As you can see, the usage code has not changed, only its\\n        // memory layout. Both approaches have their own advantages but they can\\n        // be used together to achieve different results. The subtyping approach\\n        // can allow for a greater control of the memory layout and memory\\n        // allocation, e.g. storing the derivatives together. However, this is\\n        // also its disadvantage. You must either preallocate arrays for each\\n        // derivative separation (which can be easily missed) or preallocate a\\n        // bunch of "raw" memory; determining the maximum size of the derived\\n        // types would require the aid of metaprogramming. Unions solve this\\n        // particular problem as the data is stored with the base data.\\n        // Therefore, it is possible to preallocate, e.g. [100]Entity.\\n\\n        // It should be noted that the union approach can have the same memory\\n        // layout as the any and with the same type restrictions by using a\\n        // pointer type for the derivatives.\\n\\n        /*\\n            Entity :: struct {\\n                ...\\n                derived: union{^Frog, ^Monster},\\n            }\\n\\n            Frog :: struct {\\n                using entity: Entity,\\n                ...\\n            }\\n            Monster :: struct {\\n                using entity: Entity,\\n                ...\\n\\n            }\\n            new_entity :: proc(T: type) -> ^Entity {\\n                t := new(T)\\n                t.derived = t\\n                return t\\n            }\\n        */\\n    }\\n}\\n\\nusing_statement :: proc() {\\n    fmt.println("\",\n                \"\\\\n\",\n                \"# using statement")\\n    // using can used to bring entities declared in a scope/namespace\\n    // into the current scope. This can be applied to import names, struct\\n    // fields, procedure fields, and struct values.\\n\\n    Vector3 :: struct{x, y, z: f32}\\n    {\\n        Entity :: struct {\\n            position: Vector3,\\n            orientation: quaternion128,\\n        }\\n\\n        // It can used like this:\\n        foo0 :: proc(entity: ^Entity) {\\n            fmt.println(entity.position.x, entity.position.y, entity.position.z)\\n        }\\n\\n        // The entity members can be brought into the procedure scope by using it:\\n        foo1 :: proc(entity: ^Entity) {\\n            using entity\\n            fmt.println(position.x, position.y, position.z)\\n        }\\n\\n        // The using can be applied to the parameter directly:\\n        foo2 :: proc(using entity: ^Entity) {\\n            fmt.println(position.x, position.y, position.z)\\n        }\\n\\n        // It can also be applied to sub-fields:\\n        foo3 :: proc(entity: ^Entity) {\\n            using entity.position\\n            fmt.println(x, y, z)\\n        }\\n    }\\n    {\\n        // We can also apply the using statement to the struct fields directly,\\n        // making all the fields of position appear as if they on Entity itself:\\n        Entity :: struct {\\n            using position: Vector3,\\n            orientation: quaternion128,\\n        }\\n        foo :: proc(entity: ^Entity) {\\n            fmt.println(entity.x, entity.y, entity.z)\\n        }\\n\\n\\n        // Subtype polymorphism\\n        // It is possible to get subtype polymorphism, similar to inheritance-like\\n        // functionality in C++, but without the requirement of vtables or unknown\\n        // struct layout:\\n\\n        Colour :: struct {r, g, b, a: u8}\\n        Frog :: struct {\\n            ribbit_volume: f32,\\n            using entity: Entity,\\n            colour: Colour,\\n        }\\n\\n        frog: Frog\\n        // Both work\\n        foo(&frog.entity)\\n        foo(&frog)\\n        frog.x = 123\\n\\n        // Note: using can be applied to arbitrarily many things, which allows\\n        // the ability to have multiple subtype polymorphism (but also its issues).\\n\\n        // Note: using’d fields can still be referred by name.\\n    }\\n}\\n\\n\\nimplicit_context_system :: proc() {\\n    fmt.println("\",\n                \"\\\\n\",\n                \"# implicit context system")\\n    // In each scope, there is an implicit value named context. This\\n    // context variable is local to each scope and is implicitly passed\\n    // by pointer to any procedure call in that scope (if the procedure\\n    // has the Odin calling convention).\\n\\n    // The main purpose of the implicit context system is for the ability\\n    // to intercept third-party code and libraries and modify their\\n    // functionality. One such case is modifying how a library allocates\\n    // something or logs something. In C, this was usually achieved with\\n    // the library defining macros which could be overridden so that the\\n    // user could define what he wanted. However, not many libraries\\n    // supported this in many languages by default which meant intercepting\\n    // third-party code to see what it does and to change how it does it is\\n    // not possible.\\n\\n    c := context // copy the current scope'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"s \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n\\n    \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \".user_index = \",\n        {\n            \"children\": [\n                \"456\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    {\\n        \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \".allocator = my_custom_allocator()\\n        \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \".user_index = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        what_a_fool_believes() \",\n        {\n            \"children\": [\n                \"// the `context`\",\n                \" for this scope \",\n                \"is\",\n                \" implicitly passed to \",\n                \"`what_a_fool_believes`\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n\\n    \",\n        {\n            \"children\": [\n                \"// `context`\",\n                \" value is local \",\n                \"to\",\n                \" the scope it \",\n                \"is in\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    assert(\",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \".user_index == \",\n        {\n            \"children\": [\n                \"456\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n\\n    what_a_fool_believes :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n        c := \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// this `context`\",\n                \" is the same \",\n                \"as\",\n                \" the parent procedure \",\n                \"that\",\n                \" it was called \",\n                \"from\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// From this example, context.user_index == 123\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// An context.allocator\",\n                \" is assigned to \",\n                \"the return value of `my_custom_allocator()`\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        assert(\",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \".user_index == \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The memory management \",\n                \"procedure use the `context.allocator` by\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" default unless explicitly \",\n                \"specified otherwise\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        china_grove := new(\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n        free(china_grove)\\n\\n        _ = c\\n    }\\n\\n    my_custom_allocator :: mem.nil_allocator\\n    _ = c\\n\\n    \",\n        {\n            \"children\": [\n                \"// By default,\",\n                \" the context value \",\n                \"has\",\n                \" default values for \",\n                \"its parameters which is\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" decided in the \",\n                \"package\",\n                \" runtime. What the \",\n                \"defaults\",\n                \" are are compiler \",\n                \"specific.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n    \",\n        {\n            \"children\": [\n                \"// To\",\n                \" see what the \",\n                \"implicit context value contains,\",\n                \" please see the \",\n                \"following\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" definition in package \",\n                \"runtime.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n}\\n\\nparametric_polymorphism :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# parametric polymorphism")\\n\\n    print_value :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(value: $T) {\\n        fmt.printf("print_value: %T %v\\\\n", value, value)\\n    }\\n\\n    v1: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"    = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    v2: \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"    = \",\n        {\n            \"children\": [\n                \"2.1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    v3: \",\n        {\n            \"children\": [\n                \"f64\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"    = \",\n        {\n            \"children\": [\n                \"3.14\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    v4: \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" = "message"\\n\\n    print_value(v1)\\n    print_value(v2)\\n    print_value(v3)\\n    print_value(v4)\\n\\n    fmt.println()\\n\\n    add :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(p, q: $T) -> T {\\n        x: T = p + q\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x\\n    }\\n\\n    a := add(\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n    fmt.printf("a: %T = %v\\\\n", a, a)\\n\\n    b := add(\",\n        {\n            \"children\": [\n                \"3.2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4.3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n    fmt.printf("b: %T = %v\\\\n", b, b)\\n\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" This is how \",\n                \"`new` is implemented\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    alloc_type :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"($T: \",\n        {\n            \"children\": [\n                \"typeid\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \") -> ^T {\\n        t := \",\n        {\n            \"children\": [\n                \"cast\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(^T)alloc(size_of(T), align_of(T))\\n        t^ = T{} \",\n        {\n            \"children\": [\n                \"//\",\n                \" Use default initialization \",\n                \"value\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" t\\n    }\\n\\n    copy_slice :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(dst, src: []$T) -> \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n        n := min(len(dst), len(src))\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" n > \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            mem.copy(&dst[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"], &src[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"], n*size_of(T))\\n        }\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" n\\n    }\\n\\n    double_params :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a: $A, b: $B) -> A {\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" a + A(b)\\n    }\\n\\n    fmt.println(double_params(\",\n        {\n            \"children\": [\n                \"12\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1.345\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"))\\n\\n\\n\\n    { \",\n        {\n            \"children\": [\n                \"//\",\n                \" Polymorphic Types and \",\n                \"Type Specialization\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        Table_Slot :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"($Key, $Value: \",\n        {\n            \"children\": [\n                \"typeid\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \") {\\n            occupied: \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n            hash:     \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n            key:      Key,\\n            value:    Value,\\n        }\\n        TABLE_SIZE_MIN :: \",\n        {\n            \"children\": [\n                \"32\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        Table :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"($Key, $Value: \",\n        {\n            \"children\": [\n                \"typeid\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \") {\\n            count:     \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n            allocator: mem.Allocator,\\n            slots:     []Table_Slot(Key, Value),\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Only allow types \",\n                \"that are specializations of a (polymorphic) slice\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        make_slice :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"($T: \",\n        {\n            \"children\": [\n                \"typeid\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"/[]$E, len: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> T {\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" make(T, len)\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Only allow types \",\n                \"that are specializations of `Table`\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        allocate :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(table: ^$T/Table, capacity: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") {\\n            c := \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" table.allocator.procedure != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n                c.allocator = table.allocator\\n            }\\n            \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" = c\\n\\n            table.slots = make_slice(type_of(table.slots), max(capacity, TABLE_SIZE_MIN))\\n        }\\n\\n        expand :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(table: ^$T/Table) {\\n            c := \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" table.allocator.procedure != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n                c.allocator = table.allocator\\n            }\\n            \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" = c\\n\\n            old_slots := table.slots\\n            \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" delete(old_slots)\\n\\n            cap := max(\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"*len(table.slots), TABLE_SIZE_MIN)\\n            allocate(table, cap)\\n\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" s \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" old_slots {\\n                \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" s.occupied {\\n                    put(table, s.key, s.value)\\n                }\\n            }\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// Polymorphic determination of a polymorphic struct\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// put :: proc(table: ^$T/Table, key: T.Key, value: T.Value) {\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        put :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(table: ^Table($Key, $Value), key: Key, value: Value) {\\n            hash := get_hash(key) \",\n        {\n            \"children\": [\n                \"//\",\n                \" Ad-hoc method which \",\n                \"would\",\n                \" fail in a \",\n                \"different scope\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            index := find_index(table, key, hash)\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" index < \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n                \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"f64\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(table.count) >= \",\n        {\n            \"children\": [\n                \"0.75\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"*\",\n        {\n            \"children\": [\n                \"f64\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(len(table.slots)) {\\n                    expand(table)\\n                }\\n                assert(table.count <= len(table.slots))\\n\\n                index = \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(hash % \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(len(table.slots)))\\n\\n                \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" table.slots[index].occupied {\\n                    \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" index += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; index >= len(table.slots) {\\n                        index = \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n                    }\\n                }\\n\\n                table.count += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n            }\\n\\n            slot := &table.slots[index]\\n            slot.occupied = \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n            slot.hash     = hash\\n            slot.key      = key\\n            slot.value    = value\\n        }\\n\\n\\n        \",\n        {\n            \"children\": [\n                \"// find :: proc(table: ^$T/Table, key: T.Key) -> (T.Value, bool) {\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        find :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(table: ^Table($Key, $Value), key: Key) -> (Value, \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") {\\n            hash := get_hash(key)\\n            index := find_index(table, key, hash)\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" index < \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n                \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" Value{}, \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n            }\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" table.slots[index].value, \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n        }\\n\\n        find_index :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(table: ^Table($Key, $Value), key: Key, hash: \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" len(table.slots) <= \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n                \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" -\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n            }\\n\\n            index := \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(hash % \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(len(table.slots)))\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" table.slots[index].occupied {\\n                \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" table.slots[index].hash == hash {\\n                    \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" table.slots[index].key == key {\\n                        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" index\\n                    }\\n                }\\n\\n                \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" index += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; index >= len(table.slots) {\\n                    index = \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n                }\\n            }\\n\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" -\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        }\\n\\n        get_hash :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(s: \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" { \",\n        {\n            \"children\": [\n                \"// fnv32a\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            h: \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"x811c9dc5\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<len(s) {\\n                h = (h ~ \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(s[i])) * \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"x01000193\\n            }\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" h\\n        }\\n\\n\\n        table: Table(\",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".=\",\n        {\n            \"children\": [\n                \"36\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" { put(&table, "Hellope", i) }\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".=\",\n        {\n            \"children\": [\n                \"42\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" { put(&table, "World!",  i) }\\n\\n        found, _ := find(&table, "Hellope")\\n        fmt.printf("\",\n        {\n            \"children\": [\n                \"`found`\"\n            ],\n            \"scope\": \"string\"\n        },\n        \" is %v\\\\n", found)\\n\\n        found, _ = find(&table, "World!")\\n        fmt.printf("\",\n        {\n            \"children\": [\n                \"`found`\"\n            ],\n            \"scope\": \"string\"\n        },\n        \" is %v\\\\n", found)\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" I would not \",\n                \"personally\",\n                \" design a hash \",\n                \"table\",\n                \" like this in \",\n                \"production\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" but this is \",\n                \"a nice basic example\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// A\",\n                \" better approach would \",\n                \"either use a `u64` or\",\n                \" equivalent for the \",\n                \"key\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" and let the \",\n                \"user\",\n                \" specify the hashing \",\n                \"function or\",\n                \" make the user \",\n                \"store\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" the hashing procedure \",\n                \"with the table\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Parametric polymorphic union\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        Error :: \",\n        {\n            \"children\": [\n                \"enum\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            Foo0,\\n            Foo1,\\n            Foo2,\\n            Foo3,\\n        }\\n        Para_Union :: \",\n        {\n            \"children\": [\n                \"union\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"($T: \",\n        {\n            \"children\": [\n                \"typeid\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \") {T, Error}\\n        r: Para_Union(\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n        fmt.println(typeid_of(type_of(r)))\\n\\n        fmt.println(r)\\n        r = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        fmt.println(r)\\n        r = Error.Foo0 \",\n        {\n            \"children\": [\n                \"// r = .Foo0 is allow too,\",\n                \" see implicit selector \",\n                \"expressions below\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println(r)\\n    }\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Polymorphic names\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        foo :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"($N: $I, $T: \",\n        {\n            \"children\": [\n                \"typeid\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \") -> (res: [N]T) {\\n            \",\n        {\n            \"children\": [\n                \"// `N`\",\n                \" is the constant \",\n                \"value passed\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"// `I`\",\n                \" is the type \",\n                \"of N\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"// `T`\",\n                \" is the type \",\n                \"passed\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            fmt.printf("Generating an array of type %v from the value %v of type %v\\\\n",\\n                       typeid_of(type_of(res)), N, typeid_of(I))\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<N {\\n                res[i] = T(i*i)\\n            }\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n        }\\n\\n        T :: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        array := foo(\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", T)\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" v, i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" array {\\n            assert(v == T(i*i))\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// Matrix multiplication\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        mul :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a: [$M][$N]$T, b: [N][$P]T) -> (c: [M][P]T) {\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<M {\\n                \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" j \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<P {\\n                    \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" k \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<N {\\n                        c[i][j] += a[i][k] * b[k][j]\\n                    }\\n                }\\n            }\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n        }\\n\\n        x := [\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"][\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n            {\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"},\\n            {\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"},\\n        }\\n        y := [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"][\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n            {\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"8\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"},\\n            {\",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"},\\n            {\",\n        {\n            \"children\": [\n                \"8\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"},\\n        }\\n        z := mul(x, y)\\n        assert(z == {{\",\n        {\n            \"children\": [\n                \"36\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"24\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}, {\",\n        {\n            \"children\": [\n                \"20\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"32\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}})\\n    }\\n}\\n\\n\\nprefix_table := [?]\",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n    "White",\\n    "Red",\\n    "Green",\\n    "Blue",\\n    "Octarine",\\n    "Black",\\n}\\n\\nprint_mutex := \",\n        {\n            \"children\": [\n                \"b64\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \")\\n\\nthreading_example :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# threading_example")\\n\\n    did_acquire :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(m: ^\",\n        {\n            \"children\": [\n                \"b64\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> (acquired: \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") {\\n        res, ok := intrinsics.atomic_compare_exchange_strong(m, \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \")\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" ok && res == \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n    }\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Basic Threads\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println("\\\\n## Basic Threads")\\n        worker_proc :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(t: ^thread.Thread) {\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" iteration \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"1.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".=\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n                fmt.printf("Thread %d is on iteration %d\\\\n", t.user_index, iteration)\\n                fmt.printf("\",\n        {\n            \"children\": [\n                \"`%s`\"\n            ],\n            \"scope\": \"string\"\n        },\n        \": iteration %d\\\\n", prefix_table[t.user_index], iteration)\\n                time.sleep(\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" * time.Millisecond)\\n            }\\n        }\\n\\n        threads := make([\",\n        {\n            \"children\": [\n                \"dynamic\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"]^thread.Thread, \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", len(prefix_table))\\n        \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" delete(threads)\\n\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" prefix_table {\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" t := thread.create(worker_proc); t != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n                t.init_context = \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n                t.user_index = len(threads)\\n                append(&threads, t)\\n                thread.start(t)\\n            }\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" len(threads) > \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i := \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; i < len(threads); \",\n        {\n            \"children\": [\n                \"/**/\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \" {\\n                \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" t := threads[i]; thread.is_done(t) {\\n                    fmt.printf("Thread %d is done\\\\n", t.user_index)\\n                    thread.destroy(t)\\n\\n                    ordered_remove(&threads, i)\\n                } \",\n        {\n            \"children\": [\n                \"else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n                    i += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n                }\\n            }\\n        }\\n    }\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Thread Pool\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println("\\\\n## Thread Pool")\\n        task_proc :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(t: thread.Task) {\\n            index := t.user_index % len(prefix_table)\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" iteration \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"1.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".=\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n                \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" !did_acquire(&print_mutex) { thread.yield() } \",\n        {\n            \"children\": [\n                \"//\",\n                \" Allow one thread \",\n                \"to\",\n                \" print at a \",\n                \"time.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n                fmt.printf("Worker Task %d is on iteration %d\\\\n", t.user_index, iteration)\\n                fmt.printf("\",\n        {\n            \"children\": [\n                \"`%s`\"\n            ],\n            \"scope\": \"string\"\n        },\n        \": iteration %d\\\\n", prefix_table[index], iteration)\\n\\n                print_mutex = \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n\\n                time.sleep(\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" * time.Millisecond)\\n            }\\n        }\\n\\n        N :: \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n        pool: thread.Pool\\n        thread.pool_init(pool=&pool, thread_count=N, allocator=\",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \".allocator)\\n        \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" thread.pool_destroy(&pool)\\n\\n\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"30\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"// be mindful of\",\n                \" the allocator used \",\n                \"for\",\n                \" tasks. The allocator \",\n                \"needs to be thread safe, or be owned by\",\n                \" the task for \",\n                \"exclusive use \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            thread.pool_add_task(pool=&pool, procedure=task_proc, data=\",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \", user_index=i, allocator=\",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \".allocator)\\n        }\\n\\n        thread.pool_start(&pool)\\n\\n        {\\n            \",\n        {\n            \"children\": [\n                \"//\",\n                \" Wait a moment \",\n                \"before we cancel a thread\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            time.sleep(\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" * time.Millisecond)\\n\\n            \",\n        {\n            \"children\": [\n                \"//\",\n                \" Allow one thread \",\n                \"to\",\n                \" print at a \",\n                \"time.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" !did_acquire(&print_mutex) { thread.yield() }\\n\\n            thread.terminate(pool.threads[N - \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"], \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n            fmt.println("Canceled last thread")\\n            print_mutex = \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n        }\\n\\n        thread.pool_finish(&pool)\\n    }\\n}\\n\\n\\narray_programming :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# array programming")\\n    {\\n        a := [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        b := [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"7\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        c := a * b\\n        d := a + b\\n        e := \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" +  (c - d) / \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        fmt.printf("%.\",\n        {\n            \"children\": [\n                \"1f\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\\\n", e) \",\n        {\n            \"children\": [\n                \"// [0.5, 3.0, 6.5]\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n\\n    {\\n        a := [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        b := swizzle(a, \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        assert(b == [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"})\\n\\n        c := swizzle(a, \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        assert(c == [\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"})\\n        assert(c == \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n    }\\n\\n    {\\n        Vector3 :: \",\n        {\n            \"children\": [\n                \"distinct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        a := Vector3{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        b := Vector3{\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"7\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        c := (a * b)/\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        d := c.x + c.y + c.z\\n        fmt.printf("%.\",\n        {\n            \"children\": [\n                \"1f\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\\\n", d) \",\n        {\n            \"children\": [\n                \"// 22.0\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        cross :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a, b: Vector3) -> Vector3 {\\n            i := swizzle(a, \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \") * swizzle(b, \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n            j := swizzle(a, \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \") * swizzle(b, \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i - j\\n        }\\n\\n        cross_shorter :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a, b: Vector3) -> Vector3 {\\n            i := a.yzx * b.zxy\\n            j := a.zxy * b.yzx\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i - j\\n        }\\n\\n        blah :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a: Vector3) -> \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" a.x + a.y + a.z\\n        }\\n\\n        x := cross(a, b)\\n        fmt.println(x)\\n        fmt.println(blah(x))\\n    }\\n}\\n\\nmap_type :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# \",\n        {\n            \"children\": [\n                \"map\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" type")\\n\\n    m := make(\",\n        {\n            \"children\": [\n                \"map\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"[\",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n    \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" delete(m)\\n\\n    m["Bob"] = \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    m["Ted"] = \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    fmt.println(m["Bob"])\\n\\n    delete_key(&m, "Ted")\\n\\n    \",\n        {\n            \"children\": [\n                \"// If an element of\",\n                \" a key does \",\n                \"not exist,\",\n                \" the zero value \",\n                \"of the\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// element will be returned. To\",\n                \" check to see \",\n                \"if an element exists\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// can be\",\n                \" done in two \",\n                \"ways:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    elem, ok := m["Bob"]\\n    exists := "Bob" \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" m\\n    _, _ = elem, ok\\n    _ = exists\\n}\\n\\nimplicit_selector_expression :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# implicit selector expression")\\n\\n    Foo :: \",\n        {\n            \"children\": [\n                \"enum\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {A, B, C}\\n\\n    f: Foo\\n    f = Foo.A\\n    f = .A\\n\\n    BAR :: \",\n        {\n            \"children\": [\n                \"bit_set\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"[Foo]{.B, .C}\\n\\n    \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" f {\\n    \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .A:\\n        fmt.println("HITHER")\\n    \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .B:\\n        fmt.println("NEVER")\\n    \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .C:\\n        fmt.println("FOREVER")\\n    }\\n\\n    my_map := make(\",\n        {\n            \"children\": [\n                \"map\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"[Foo]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n    \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" delete(my_map)\\n\\n    my_map[.A] = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    my_map[Foo.B] = \",\n        {\n            \"children\": [\n                \"345\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n    fmt.println(my_map[.A] + my_map[Foo.B] + my_map[.C])\\n}\\n\\n\\npartial_switch :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# partial_switch")\\n    { \",\n        {\n            \"children\": [\n                \"// enum\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        Foo :: \",\n        {\n            \"children\": [\n                \"enum\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            A,\\n            B,\\n            C,\\n            D,\\n        }\\n\\n        f := Foo.A\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" f {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .A: fmt.println("A")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .B: fmt.println("B")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .C: fmt.println("C")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .D: fmt.println("D")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \":    fmt.println("?")\\n        }\\n\\n        #partial \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" f {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .A: fmt.println("A")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .D: fmt.println("D")\\n        }\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"// union\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        Foo :: \",\n        {\n            \"children\": [\n                \"union\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"}\\n        f: Foo = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" f {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \":  fmt.println("\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \": fmt.println("\",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"")\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \":\\n        }\\n\\n        #partial \",\n        {\n            \"children\": [\n                \"switch\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" f {\\n        \",\n        {\n            \"children\": [\n                \"case\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \": fmt.println("\",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"")\\n        }\\n    }\\n}\\n\\ncstring_example :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# cstring_example")\\n\\n    W :: "Hellope"\\n    X :: \",\n        {\n            \"children\": [\n                \"cstring\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(W)\\n    Y :: \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(X)\\n\\n    w := W\\n    _ = w\\n    x: \",\n        {\n            \"children\": [\n                \"cstring\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" = X\\n    y: \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" = Y\\n    z := \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(x)\\n    fmt.println(x, y, z)\\n    fmt.println(len(x), len(y), len(z))\\n    fmt.println(len(W), len(X), len(Y))\\n    \",\n        {\n            \"children\": [\n                \"// IMPORTANT NOTE for cstring variables\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// len(cstring) is O(N)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// cast(string)cstring is O(N)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n}\\n\\nbit_set_type :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# \",\n        {\n            \"children\": [\n                \"bit_set\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" type")\\n\\n    {\\n        Day :: \",\n        {\n            \"children\": [\n                \"enum\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            Sunday,\\n            Monday,\\n            Tuesday,\\n            Wednesday,\\n            Thursday,\\n            Friday,\\n            Saturday,\\n        }\\n\\n        Days :: \",\n        {\n            \"children\": [\n                \"distinct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"bit_set\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"[Day]\\n        WEEKEND :: Days{.Sunday, .Saturday}\\n\\n        d: Days\\n        d = {.Sunday, .Monday}\\n        e := d + WEEKEND\\n        e += {.Monday}\\n        fmt.println(d, e)\\n\\n        ok := .Saturday \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" e \",\n        {\n            \"children\": [\n                \"// `in`\",\n                \" is only allowed \",\n                \"for `map` and `bit_set` types\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println(ok)\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .Saturday \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" e {\\n            fmt.println("Saturday \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"", e)\\n        }\\n        X :: .Saturday \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" WEEKEND \",\n        {\n            \"children\": [\n                \"// Constant evaluation\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println(X)\\n        fmt.println("Cardinality:", card(e))\\n    }\\n    {\\n        x: \",\n        {\n            \"children\": [\n                \"bit_set\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"[\",\n        {\n            \"children\": [\n                \"'A'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"..=\",\n        {\n            \"children\": [\n                \"'Z'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"]\\n        #assert(size_of(x) == size_of(\",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"))\\n        y: \",\n        {\n            \"children\": [\n                \"bit_set\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"[\",\n        {\n            \"children\": [\n                \"0.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".=\",\n        {\n            \"children\": [\n                \"8\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"; \",\n        {\n            \"children\": [\n                \"u16\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"]\\n        fmt.println(typeid_of(type_of(x))) \",\n        {\n            \"children\": [\n                \"// bit_set[A..=Z]\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println(typeid_of(type_of(y))) \",\n        {\n            \"children\": [\n                \"// bit_set[0..=8; u16]\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        x += {\",\n        {\n            \"children\": [\n                \"'F'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"}\\n        assert(\",\n        {\n            \"children\": [\n                \"'F'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x)\\n        x -= {\",\n        {\n            \"children\": [\n                \"'F'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"}\\n        assert(\",\n        {\n            \"children\": [\n                \"'F'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"not_in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x)\\n\\n        y += {\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        assert(\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" y)\\n    }\\n    {\\n        Letters :: \",\n        {\n            \"children\": [\n                \"bit_set\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"[\",\n        {\n            \"children\": [\n                \"'A'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"..=\",\n        {\n            \"children\": [\n                \"'Z'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"]\\n        a := Letters{\",\n        {\n            \"children\": [\n                \"'A'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"'B'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"}\\n        b := Letters{\",\n        {\n            \"children\": [\n                \"'A'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"'B'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"'C'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"'D'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"'F'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"}\\n        c := Letters{\",\n        {\n            \"children\": [\n                \"'A'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"'B'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"}\\n\\n        assert(a <= b) \",\n        {\n            \"children\": [\n                \"// 'a'\",\n                \" is a subset \",\n                \"of 'b'\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        assert(b >= a) \",\n        {\n            \"children\": [\n                \"// 'b'\",\n                \" is a superset \",\n                \"of 'a'\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        assert(a < b)  \",\n        {\n            \"children\": [\n                \"// 'a'\",\n                \" is a strict \",\n                \"subset of 'b'\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        assert(b > a)  \",\n        {\n            \"children\": [\n                \"// 'b'\",\n                \" is a strict \",\n                \"superset of 'a'\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        assert(!(a < c)) \",\n        {\n            \"children\": [\n                \"// 'a'\",\n                \" is a not \",\n                \"strict subset of 'c'\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        assert(!(c > a)) \",\n        {\n            \"children\": [\n                \"// 'c'\",\n                \" is a not \",\n                \"strict superset of 'a'\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n}\\n\\ndeferred_procedure_associations :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# deferred procedure associations")\\n\\n    @(deferred_out=closure)\\n    open :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(s: \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n        fmt.println(s)\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n    }\\n\\n    closure :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(ok: \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") {\\n        fmt.println("Goodbye?", ok)\\n    }\\n\\n    \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" open("Welcome") {\\n        fmt.println("Something \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" the middle, mate.")\\n    }\\n}\\n\\nreflection :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# reflection")\\n\\n    Foo :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n        x: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"    \",\n        {\n            \"children\": [\n                \"`tag1`\"\n            ],\n            \"scope\": \"string\"\n        },\n        \",\\n        y: \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"`json:"y_field"`\"\n            ],\n            \"scope\": \"string\"\n        },\n        \",\\n        z: \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"// no tag\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n\\n    id := typeid_of(Foo)\\n    names := reflect.struct_field_names(id)\\n    types := reflect.struct_field_types(id)\\n    tags  := reflect.struct_field_tags(id)\\n\\n    assert(len(names) == len(types) && len(names) == len(tags))\\n\\n    fmt.println("Foo :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {")\\n    \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" tag, i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" tags {\\n        name, type := names[i], types[i]\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" tag != "" {\\n            fmt.printf("\\\\t%s: %T \",\n        {\n            \"children\": [\n                \"`%s`\"\n            ],\n            \"scope\": \"string\"\n        },\n        \",\\\\n", name, type, tag)\\n        } \",\n        {\n            \"children\": [\n                \"else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            fmt.printf("\\\\t%s: %T,\\\\n", name, type)\\n        }\\n    }\\n    fmt.println("}")\\n\\n\\n    \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" tag, i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" tags {\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" val, ok := reflect.struct_tag_lookup(tag, "json"); ok {\\n            fmt.printf("json: %s -> %s\\\\n", names[i], val)\\n        }\\n    }\\n}\\n\\nquaternions :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    \",\n        {\n            \"children\": [\n                \"// Not just an\",\n                \" April Fool's Joke \",\n                \"any more,\",\n                \" but a fully \",\n                \"working thing!\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    fmt.println("\\\\n# quaternions")\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Quaternion operations\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        q := \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + \",\n        {\n            \"children\": [\n                \"2i\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"j + \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"k\\n        r := quaternion(\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"7\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"8\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        t := q * r\\n        fmt.printf("(%v) * (%v) = %v\\\\n", q, r, t)\\n        v := q / r\\n        fmt.printf("(%v) / (%v) = %v\\\\n", q, r, v)\\n        u := q + r\\n        fmt.printf("(%v) + (%v) = %v\\\\n", q, r, u)\\n        s := q - r\\n        fmt.printf("(%v) - (%v) = %v\\\\n", q, r, s)\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"// The quaternion types\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        q128: \",\n        {\n            \"children\": [\n                \"quaternion128\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// 4xf32\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        q256: \",\n        {\n            \"children\": [\n                \"quaternion256\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// 4xf64\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        q128 = quaternion(\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        q256 = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// quaternion(1, 0, 0, 0)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"// Built-in procedures\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        q := \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + \",\n        {\n            \"children\": [\n                \"2i\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"j + \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"k\\n        fmt.println("q =", q)\\n        fmt.println("real(q) =", real(q))\\n        fmt.println("imag(q) =", imag(q))\\n        fmt.println("jmag(q) =", jmag(q))\\n        fmt.println("kmag(q) =", kmag(q))\\n        fmt.println("conj(q) =", conj(q))\\n        fmt.println("abs(q)  =", abs(q))\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"// Conversion of\",\n                \" a complex type \",\n                \"to a quaternion type\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        c := \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + \",\n        {\n            \"children\": [\n                \"2i\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        q := \",\n        {\n            \"children\": [\n                \"quaternion256\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(c)\\n        fmt.println(c)\\n        fmt.println(q)\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"// Memory layout of Quaternions\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        q := \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + \",\n        {\n            \"children\": [\n                \"2i\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"j + \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"k\\n        a := \",\n        {\n            \"children\": [\n                \"transmute\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"([\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f64\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")q\\n        fmt.println("Quaternion memory layout: xyzw/(ijkr)")\\n        fmt.println(q) \",\n        {\n            \"children\": [\n                \"// 1.000+2.000i+3.000j+4.000k\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println(a) \",\n        {\n            \"children\": [\n                \"// [2.000, 3.000, 4.000, 1.000]\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n}\\n\\nunroll_for_statement :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#\",\n        {\n            \"children\": [\n                \"'#unroll for'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \" statements")\\n\\n    \",\n        {\n            \"children\": [\n                \"// '#unroll for'\",\n                \" works the same \",\n                \"as if the 'inline' prefix did not\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" exist but these \",\n                \"ranged\",\n                \" loops are explicitly \",\n                \"unrolled which can\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// be\",\n                \" very very useful \",\n                \"for certain optimizations\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n    fmt.println("Ranges")\\n    #unroll \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" x, i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"1.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n        fmt.println(x, i)\\n    }\\n\\n    fmt.println("Strings")\\n    #unroll \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" r, i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "Hello, 世界" {\\n        fmt.println(r, i)\\n    }\\n\\n    fmt.println("Arrays")\\n    #unroll \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" elem, idx \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" ([\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}) {\\n        fmt.println(elem, idx)\\n    }\\n\\n\\n    Foo_Enum :: \",\n        {\n            \"children\": [\n                \"enum\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n        A = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        B,\\n        C = \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        D,\\n    }\\n    fmt.println("Enum types")\\n    #unroll \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" elem, idx \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" Foo_Enum {\\n        fmt.println(elem, idx)\\n    }\\n}\\n\\nwhere_clauses :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#procedure \",\n        {\n            \"children\": [\n                \"'where'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \" clauses")\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Sanity checks\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        simple_sanity_check :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(x: [\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n            \",\n        {\n            \"children\": [\n                \"where\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" len(x) > \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n                  type_of(x) == [\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n            fmt.println(x)\\n        }\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"// Parametric polymorphism checks\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        cross_2d :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a, b: $T/[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]$E) -> E\\n            \",\n        {\n            \"children\": [\n                \"where\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" intrinsics.type_is_numeric(E) {\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" a.x*b.y - a.y*b.x\\n        }\\n        cross_3d :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(a, b: $T/[\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]$E) -> T\\n            \",\n        {\n            \"children\": [\n                \"where\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" intrinsics.type_is_numeric(E) {\\n            x := a.y*b.z - a.z*b.y\\n            y := a.z*b.x - a.x*b.z\\n            z := a.x*b.y - a.y*b.z\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" T{x, y, z}\\n        }\\n\\n        a := [\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        b := [\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", -\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        fmt.println(cross_2d(a, b))\\n\\n        x := [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        y := [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{-\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        fmt.println(cross_3d(x, y))\\n\\n        \",\n        {\n            \"children\": [\n                \"// Failure case\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// i := [2]bool{true, false}\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// j := [2]bool{false, true}\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// fmt.println(cross_2d(i, j))\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n    }\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Procedure groups usage\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        foo :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(x: [$N]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"where\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" N > \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println(#procedure, "was called with the parameter", x)\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n        }\\n\\n        bar :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(x: [$N]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"where\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" < N,\\n                  N <= \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            fmt.println(#procedure, "was called with the parameter", x)\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"\\n        }\\n\\n        baz :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"{foo, bar}\\n\\n        x := [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        y := [\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        ok_x := baz(x)\\n        ok_y := baz(y)\\n        assert(ok_x == \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \")\\n        assert(ok_y == \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \")\\n    }\\n\\n    { \",\n        {\n            \"children\": [\n                \"// Record types\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        Foo :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"($T: \",\n        {\n            \"children\": [\n                \"typeid\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \", $N: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n            \",\n        {\n            \"children\": [\n                \"where\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" intrinsics.type_is_integer(T),\\n                  N > \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" {\\n            x: [N]T,\\n            y: [N-\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]T,\\n        }\\n\\n        T :: \",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        N :: \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        f: Foo(T, N)\\n        #assert(size_of(f) == (N+N-\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")*size_of(T))\\n    }\\n}\\n\\n\\n\",\n        {\n            \"children\": [\n                \"when\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" ODIN_OS == .Windows {\\n    \",\n        {\n            \"children\": [\n                \"foreign\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"import\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" kernel32 "system:kernel32.lib"\\n}\\n\\nforeign_system :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#\",\n        {\n            \"children\": [\n                \"foreign\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" system")\\n    \",\n        {\n            \"children\": [\n                \"when\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" ODIN_OS == .Windows {\\n        \",\n        {\n            \"children\": [\n                \"// It\",\n                \" is sometimes necessarily \",\n                \"to\",\n                \" interface with foreign \",\n                \"code,\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// such as a C library. In Odin,\",\n                \" this is achieved \",\n                \"through the\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" foreign system. You \",\n                \"can “import”\",\n                \" a library into \",\n                \"the code\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" using the same \",\n                \"semantics as\",\n                \" a normal import \",\n                \"declaration.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" This foreign import \",\n                \"declaration will create a\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// “foreign import name”\",\n                \" which can then \",\n                \"be used to associate\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" entities within a \",\n                \"foreign block.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"foreign\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" kernel32 {\\n            ExitProcess :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "stdcall" (exit_code: \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") ---\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Foreign procedure declarations \",\n                \"have the cdecl/c calling\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// convention by\",\n                \" default unless specified \",\n                \"otherwise. Due to\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// foreign procedures do\",\n                \" not have a \",\n                \"body declared within this\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// code,\",\n                \" you need append \",\n                \"the ---\",\n                \" symbol to the \",\n                \"end to distinguish\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// it as\",\n                \" a procedure literal \",\n                \"without\",\n                \" a body and \",\n                \"not a procedure type.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The attributes system \",\n                \"can be\",\n                \" used to change \",\n                \"specific properties\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// of\",\n                \" entities declared within \",\n                \"a block:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        @(default_calling_convention = "std")\\n        \",\n        {\n            \"children\": [\n                \"foreign\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" kernel32 {\\n            @(link_name="GetLastError") get_last_error :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> \",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" ---\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Example using the \",\n                \"link_prefix attribute\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        @(default_calling_convention = "std")\\n        @(link_prefix = "Get")\\n        \",\n        {\n            \"children\": [\n                \"foreign\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" kernel32 {\\n            LastError :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> \",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" ---\\n        }\\n    }\\n}\\n\\nranged_fields_for_array_compound_literals :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#ranged fields \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" array compound literals")\\n    { \",\n        {\n            \"children\": [\n                \"// Normal Array Literal\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        foo := [?]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        fmt.println(foo)\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"// Indexed\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        foo := [?]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n            \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        fmt.println(foo)\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"// Ranges\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        i := \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        foo := [?]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"5.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".=\",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"54\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"10.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = i*\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + (i-\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")*\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        #assert(len(foo) == \",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        fmt.println(foo) \",\n        {\n            \"children\": [\n                \"// [123, 0, 0, 0, 0, 54, 54, 54, 54, 54, 8, 8, 8, 8, 8]\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"//\",\n                \" Slice and Dynamic \",\n                \"Array support\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        i := \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        foo_slice := []\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"5.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".=\",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"54\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"10.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = i*\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + (i-\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")*\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        assert(len(foo_slice) == \",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        fmt.println(foo_slice) \",\n        {\n            \"children\": [\n                \"// [123, 0, 0, 0, 0, 54, 54, 54, 54, 54, 8, 8, 8, 8, 8]\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        foo_dynamic_array := [\",\n        {\n            \"children\": [\n                \"dynamic\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"5.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".=\",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"54\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"10.\"\n            ],\n            \"scope\": \"number\"\n        },\n        \".<\",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = i*\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" + (i-\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")*\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        assert(len(foo_dynamic_array) == \",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        fmt.println(foo_dynamic_array) \",\n        {\n            \"children\": [\n                \"// [123, 0, 0, 0, 0, 54, 54, 54, 54, 54, 8, 8, 8, 8, 8]\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    }\\n}\\n\\ndeprecated_attribute :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    @(deprecated="Use foo_v2 instead")\\n    foo_v1 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(x: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") {\\n        fmt.println("foo_v1")\\n    }\\n    foo_v2 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(x: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") {\\n        fmt.println("foo_v2")\\n    }\\n\\n    \",\n        {\n            \"children\": [\n                \"// \",\n                {\n                    \"children\": [\n                        \"NOTE:\"\n                    ],\n                    \"scope\": \"doctag\"\n                },\n                \" Uncomment to see \",\n                \"the warning messages\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// foo_v1(1)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n}\\n\\nrange_statements_with_multiple_return_values :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#range statements with multiple \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" values")\\n    My_Iterator :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n        index: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n        data:  []\",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \",\\n    }\\n    make_my_iterator :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(data: []\",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") -> My_Iterator {\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" My_Iterator{data = data}\\n    }\\n    my_iterator :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(it: ^My_Iterator) -> (val: \",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", idx: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", cond: \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") {\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" cond = it.index < len(it.data); cond {\\n            val = it.data[it.index]\\n            idx = it.index\\n            it.index += \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        }\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n    }\\n\\n    data := make([]\",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n    \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" _, i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" data {\\n        data[i] = \",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(i*i)\\n    }\\n\\n    {\\n        it := make_my_iterator(data)\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" val \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" my_iterator(&it) {\\n            fmt.println(val)\\n        }\\n    }\\n    {\\n        it := make_my_iterator(data)\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" val, idx \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" my_iterator(&it) {\\n            fmt.println(val, idx)\\n        }\\n    }\\n    {\\n        it := make_my_iterator(data)\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n            val, _, cond := my_iterator(&it)\\n            \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" !cond {\\n                \",\n        {\n            \"children\": [\n                \"break\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n            }\\n            fmt.println(val)\\n        }\\n    }\\n}\\n\\n\\nsoa_struct_layout :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#SOA Struct Layout")\\n\\n    {\\n        Vector3 :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {x, y, z: \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"}\\n\\n        N :: \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_aos: [N]Vector3\\n        v_aos[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_aos[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].y = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_aos[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].z = \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n        fmt.println(len(v_aos))\\n        fmt.println(v_aos[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n        fmt.println(v_aos[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x)\\n        fmt.println(&v_aos[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x)\\n\\n        v_aos[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"] = {\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        v_aos[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x = \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        fmt.println(v_aos[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n        fmt.println(v_aos)\\n\\n        v_soa: #soa[N]Vector3\\n\\n        v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].y = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].z = \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n\\n        \",\n        {\n            \"children\": [\n                \"// Same syntax as AOS and treat as\",\n                \" if it was \",\n                \"an array\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println(len(v_soa))\\n        fmt.println(v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n        fmt.println(v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x)\\n        fmt.println(&v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x)\\n        v_soa[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"] = {\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        v_soa[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x = \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        fmt.println(v_soa[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n\\n        \",\n        {\n            \"children\": [\n                \"// Can use SOA syntax if necessary\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        v_soa.x[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"] = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_soa.y[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"] = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_soa.z[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"] = \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        fmt.println(v_soa.x[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Same pointer addresses \",\n                \"with both syntaxes\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        assert(&v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x == &v_soa.x[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n\\n\\n        \",\n        {\n            \"children\": [\n                \"// Same fmt printing\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println(v_aos)\\n        fmt.println(v_soa)\\n    }\\n    {\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Works with arrays \",\n                \"of length <= 4\",\n                \" which have the \",\n                \"implicit fields xyzw/rgba\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        Vector3 :: \",\n        {\n            \"children\": [\n                \"distinct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n\\n        N :: \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_aos: [N]Vector3\\n        v_aos[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_aos[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].y = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_aos[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].z = \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n        v_soa: #soa[N]Vector3\\n\\n        v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].y = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v_soa[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].z = \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    }\\n    {\\n        \",\n        {\n            \"children\": [\n                \"// SOA Slices\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// Vector3 :: struct {x, y, z: f32}\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        Vector3 :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {x: \",\n        {\n            \"children\": [\n                \"i8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", y: \",\n        {\n            \"children\": [\n                \"i16\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", z: \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"}\\n\\n        N :: \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v: #soa[N]Vector3\\n        v[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].y = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        v[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].z = \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n        s: #soa[]Vector3\\n        s = v[:]\\n        assert(len(s) == N)\\n        fmt.println(s)\\n        fmt.println(s[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x)\\n\\n        a := s[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\\n        assert(len(a) == \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        fmt.println(a)\\n\\n        d: #soa[\",\n        {\n            \"children\": [\n                \"dynamic\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"]Vector3\\n\\n        append_soa(&d, Vector3{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}, Vector3{\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}, Vector3{-\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", -\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"})\\n        fmt.println(d)\\n        fmt.println(len(d))\\n        fmt.println(cap(d))\\n        fmt.println(d[:])\\n    }\\n    { \",\n        {\n            \"children\": [\n                \"// soa_zip and soa_unzip\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println("\\\\nsoa_zip and soa_unzip")\\n\\n        x := []\",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        y := []\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        z := []\",\n        {\n            \"children\": [\n                \"b32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"false\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \"}\\n\\n        \",\n        {\n            \"children\": [\n                \"// produce an #soa\",\n                \" slice the normal \",\n                \"slices passed\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        s := soa_zip(a=x, b=y, c=z)\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" iterate over the \",\n                \"#soa slice\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"for\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" v, i \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" s {\\n            fmt.println(v, i) \",\n        {\n            \"children\": [\n                \"//\",\n                \" exactly the same \",\n                \"as s[i]\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"// \",\n                {\n                    \"children\": [\n                        \"NOTE:\"\n                    ],\n                    \"scope\": \"doctag\"\n                },\n                \" 'v' is NOT\",\n                \" a temporary value \",\n                \"but\",\n                \" has a specialized \",\n                \"addressing mode\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"//\",\n                \" which means that \",\n                \"when accessing v.a etc,\",\n                \" it does the \",\n                \"correct transformation\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"// internally:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"//         s[i].a === s.a[i]\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            fmt.println(v.a, v.b, v.c)\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Recover the slices \",\n                \"from the #soa slice\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        a, b, c := soa_unzip(s)\\n        fmt.println(a, b, c)\\n    }\\n}\\n\\nconstant_literal_expressions :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#constant literal expressions")\\n\\n    Bar :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {x, y: \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"}\\n    Foo :: \",\n        {\n            \"children\": [\n                \"struct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {a, b: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"using\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" c: Bar}\\n\\n    FOO_CONST :: Foo{b = \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", a = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", c = {\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}}\\n\\n\\n    fmt.println(FOO_CONST.a)\\n    fmt.println(FOO_CONST.b)\\n    fmt.println(FOO_CONST.c)\\n    fmt.println(FOO_CONST.c.x)\\n    fmt.println(FOO_CONST.c.y)\\n    fmt.println(FOO_CONST.x) \",\n        {\n            \"children\": [\n                \"// using works as expected\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    fmt.println(FOO_CONST.y)\\n\\n    fmt.println("-------")\\n\\n    ARRAY_CONST :: [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n\\n    fmt.println(ARRAY_CONST[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n    fmt.println(ARRAY_CONST[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n    fmt.println(ARRAY_CONST[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n\\n    fmt.println("-------")\\n\\n    FOO_ARRAY_DEFAULTS :: [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]Foo{{}, {}, {}}\\n    fmt.println(FOO_ARRAY_DEFAULTS[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"].x)\\n\\n    fmt.println("-------")\\n\\n    Baz :: \",\n        {\n            \"children\": [\n                \"enum\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"{A=\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", B, C, D}\\n    ENUM_ARRAY_CONST :: [Baz]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{.A ..= .C = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", .D = \",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n\\n    fmt.println(ENUM_ARRAY_CONST[.A])\\n    fmt.println(ENUM_ARRAY_CONST[.B])\\n    fmt.println(ENUM_ARRAY_CONST[.C])\\n    fmt.println(ENUM_ARRAY_CONST[.D])\\n\\n    fmt.println("-------")\\n\\n    Sparse_Baz :: \",\n        {\n            \"children\": [\n                \"enum\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"{A=\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", B, C, D=\",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n    #assert(len(Sparse_Baz) < len(#sparse[Sparse_Baz]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"))\\n    SPARSE_ENUM_ARRAY_CONST :: #sparse[Sparse_Baz]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{.A ..= .C = \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", .D = \",\n        {\n            \"children\": [\n                \"16\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n\\n    fmt.println(SPARSE_ENUM_ARRAY_CONST[.A])\\n    fmt.println(SPARSE_ENUM_ARRAY_CONST[.B])\\n    fmt.println(SPARSE_ENUM_ARRAY_CONST[.C])\\n    fmt.println(SPARSE_ENUM_ARRAY_CONST[.D])\\n\\n    fmt.println("-------")\\n\\n\\n    STRING_CONST :: "Hellope!"\\n\\n    fmt.println(STRING_CONST[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n    fmt.println(STRING_CONST[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n    fmt.println(STRING_CONST[\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n\\n    fmt.println(STRING_CONST[\",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n    fmt.println(STRING_CONST[\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \":][:\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n}\\n\\nunion_maybe :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#\",\n        {\n            \"children\": [\n                \"union\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" based maybe")\\n\\n    \",\n        {\n            \"children\": [\n                \"// \",\n                {\n                    \"children\": [\n                        \"NOTE:\"\n                    ],\n                    \"scope\": \"doctag\"\n                },\n                \" This is already \",\n                \"built-in,\",\n                \" and this is \",\n                \"just\",\n                \" a reimplementation to \",\n                \"explain the behaviour\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    Maybe :: \",\n        {\n            \"children\": [\n                \"union\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"($T: \",\n        {\n            \"children\": [\n                \"typeid\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \") {T}\\n\\n    i: Maybe(\",\n        {\n            \"children\": [\n                \"u8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n    p: Maybe(^\",\n        {\n            \"children\": [\n                \"u8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") \",\n        {\n            \"children\": [\n                \"// No\",\n                \" tag is stored \",\n                \"for pointers,\",\n                \" nil is the \",\n                \"sentinel value\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" Tag size will \",\n                \"be as small as\",\n                \" needed for the \",\n                \"number of variants\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    #assert(size_of(i) == size_of(\",\n        {\n            \"children\": [\n                \"u8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") + size_of(\",\n        {\n            \"children\": [\n                \"u8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"))\\n    \",\n        {\n            \"children\": [\n                \"// No\",\n                \" need to store \",\n                \"a tag here, the `nil`\",\n                \" state is shared \",\n                \"with the variant's `nil`\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    #assert(size_of(p) == size_of(^\",\n        {\n            \"children\": [\n                \"u8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"))\\n\\n    i = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    x := i.?\\n    y, y_ok := p.?\\n    p = &x\\n    z, z_ok := p.?\\n\\n    fmt.println(i, p)\\n    fmt.println(x, &x)\\n    fmt.println(y, y_ok)\\n    fmt.println(z, z_ok)\\n}\\n\\ndummy_procedure :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("dummy_procedure")\\n}\\n\\nexplicit_context_definition :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" "c" () {\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" Try commenting the \",\n                \"following statement out below\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" = runtime.default_context()\\n\\n    fmt.println("\\\\n#explicit \",\n        {\n            \"children\": [\n                \"context\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" definition")\\n    dummy_procedure()\\n}\\n\\nrelative_data_types :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#relative data types")\\n\\n    x: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    ptr: #relative(\",\n        {\n            \"children\": [\n                \"i16\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") ^\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n    ptr = &x\\n    fmt.println(ptr^)\\n\\n    arr := [\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n    s := arr[:]\\n    rel_slice: #relative(\",\n        {\n            \"children\": [\n                \"i16\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") []\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n    rel_slice = s\\n    fmt.println(rel_slice)\\n    fmt.println(rel_slice[:])\\n    fmt.println(rel_slice[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"])\\n}\\n\\nor_else_operator :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#\",\n        {\n            \"children\": [\n                \"'or_else'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"")\\n    {\\n        m: \",\n        {\n            \"children\": [\n                \"map\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"[\",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        i: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        ok: \",\n        {\n            \"children\": [\n                \"bool\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" i, ok = m["hellope"]; !ok {\\n            i = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        }\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The above can \",\n                \"be mapped to 'or_else'\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        i = m["hellope"] \",\n        {\n            \"children\": [\n                \"or_else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n        assert(i == \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n    }\\n    {\\n        \",\n        {\n            \"children\": [\n                \"// 'or_else' can be\",\n                \" used with type \",\n                \"assertions too, as they\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// have optional ok semantics\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        v: \",\n        {\n            \"children\": [\n                \"union\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"f64\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"}\\n        i: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        i = v.(\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \") \",\n        {\n            \"children\": [\n                \"or_else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"  \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        i = v.? \",\n        {\n            \"children\": [\n                \"or_else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"// Type inference magic\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        assert(i == \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n\\n        m: Maybe(\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n        i = m.? \",\n        {\n            \"children\": [\n                \"or_else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"456\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        assert(i == \",\n        {\n            \"children\": [\n                \"456\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n    }\\n}\\n\\nor_return_operator :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n#\",\n        {\n            \"children\": [\n                \"'or_return'\"\n            ],\n            \"scope\": \"string\"\n        },\n        \"")\\n    \",\n        {\n            \"children\": [\n                \"// The concept of 'or_return' will work by\",\n                \" popping off the \",\n                \"end\",\n                \" value in a \",\n                \"multiple\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" valued expression and \",\n                \"checking\",\n                \" whether it was \",\n                \"not 'nil' or 'false', and if so,\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" set the end \",\n                \"return\",\n                \" value to value \",\n                \"if possible. If\",\n                \" the procedure only \",\n                \"has one\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// return value, it will do\",\n                \" a simple return. \",\n                \"If\",\n                \" the procedure had \",\n                \"multiple return\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// values, 'or_return'\",\n                \" will require that \",\n                \"all parameters be\",\n                \" named so that \",\n                \"the end\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// value could be assigned to by\",\n                \" name and then \",\n                \"an\",\n                \" empty return could \",\n                \"be called.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n    Error :: \",\n        {\n            \"children\": [\n                \"enum\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n        None,\\n        Something_Bad,\\n        Something_Worse,\\n        The_Worst,\\n        Your_Mum,\\n    }\\n\\n    caller_1 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> Error {\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .None\\n    }\\n\\n    caller_2 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> (\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", Error) {\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", .None\\n    }\\n    caller_3 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> (\",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", Error) {\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"345\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", .None\\n    }\\n\\n    foo_1 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> Error {\\n        \",\n        {\n            \"children\": [\n                \"// This can be\",\n                \" a common idiom \",\n                \"in many code bases\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        n0, err := caller_2()\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The above idiom \",\n                \"can be\",\n                \" transformed into the \",\n                \"following\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        n1 := caller_2() \",\n        {\n            \"children\": [\n                \"or_return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" And if the \",\n                \"expression is 1-valued, it can be used like this\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        caller_1() \",\n        {\n            \"children\": [\n                \"or_return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" which is functionally \",\n                \"equivalent to\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err1 := caller_1(); err1 != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err1\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Multiple return values \",\n                \"still work with 'or_return' as it only\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" pops off the \",\n                \"end\",\n                \" value in the \",\n                \"multi-valued expression\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        n0, n1 = caller_3() \",\n        {\n            \"children\": [\n                \"or_return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" .None\\n    }\\n    foo_2 :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() -> (n: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", err: Error) {\\n        \",\n        {\n            \"children\": [\n                \"// It\",\n                \" is more common \",\n                \"that\",\n                \" your procedure turns \",\n                \"multiple values\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// If 'or_return'\",\n                \" is used within \",\n                \"a\",\n                \" procedure multiple parameters \",\n                \"(2+),\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" then all the \",\n                \"parameters must be\",\n                \" named so that \",\n                \"the remaining parameters\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" so that a \",\n                \"bare 'return' statement can be used\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"// This can be\",\n                \" a common idiom \",\n                \"in many code bases\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        x: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        x, err = caller_2()\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The above idiom \",\n                \"can be\",\n                \" transformed into the \",\n                \"following\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        y := caller_2() \",\n        {\n            \"children\": [\n                \"or_return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n        _ = y\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" And if the \",\n                \"expression is 1-valued, it can be used like this\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        caller_1() \",\n        {\n            \"children\": [\n                \"or_return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" which is functionally \",\n                \"equivalent to\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err1 := caller_1(); err1 != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n            err = err1\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"// If\",\n                \" using a non-bare \",\n                \"'return' statement is required,\",\n                \" setting the return \",\n                \"values\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" using the normal \",\n                \"idiom\",\n                \" is a better \",\n                \"choice\",\n                \" and clearer to \",\n                \"read.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" z, zerr := caller_2(); zerr != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n            \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" -\",\n        {\n            \"children\": [\n                \"345\"\n            ],\n            \"scope\": \"number\"\n        },\n        \" * z, zerr\\n        }\\n\\n        \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n            fmt.println("Error \",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"", #procedure, ":" , err)\\n        }\\n\\n        n = \",\n        {\n            \"children\": [\n                \"123\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"return\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"\\n    }\\n\\n    foo_1()\\n    foo_2()\\n}\\n\\narbitrary_precision_mathematics :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# core:math/big")\\n\\n    print_bigint :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"(name: \",\n        {\n            \"children\": [\n                \"string\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", a: ^big.Int, base := \",\n        {\n            \"children\": [\n                \"i8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"10\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"), print_name := \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \", newline := \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \", print_extra_info := \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \") {\\n        big.assert_if_nil(a)\\n\\n        as, err := big.itoa(a, base)\\n        \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" delete(as)\\n\\n        cb := big.internal_count_bits(a)\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" print_name {\\n            fmt.printf(name)\\n        }\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n            fmt.printf(" (Error: %v) ", err)\\n        }\\n        fmt.printf(as)\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" print_extra_info {\\n            fmt.printf(" (base: %v, bits: %v, digits: %v)", base, cb, a.used)\\n        }\\n        \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" newline {\\n            fmt.println()\\n        }\\n    }\\n\\n    a, b, c, d, e, f, res := &big.Int{}, &big.Int{}, &big.Int{}, &big.Int{}, &big.Int{}, &big.Int{}, &big.Int{}\\n    \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" big.destroy(a, b, c, d, e, f, res)\\n\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" How many bits \",\n                \"should\",\n                \" the random prime \",\n                \"be?\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    bits   := \",\n        {\n            \"children\": [\n                \"64\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// Number of Rabin-Miller trials, -1 for automatic.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    trials := -\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" Default prime generation \",\n                \"flags\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    flags := big.Primality_Flags{}\\n\\n    err := big.internal_random_prime(a, bits, trials, flags)\\n    \",\n        {\n            \"children\": [\n                \"if\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" err != \",\n        {\n            \"children\": [\n                \"nil\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n        fmt.printf("Error %v while generating random prime.\\\\n", err)\\n    } \",\n        {\n            \"children\": [\n                \"else\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" {\\n        print_bigint("Random Prime A: ", a, \",\n        {\n            \"children\": [\n                \"10\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        fmt.printf("Random number iterations until prime found: %v\\\\n", big.RANDOM_PRIME_ITERATIONS_USED)\\n    }\\n\\n    \",\n        {\n            \"children\": [\n                \"// If we\",\n                \" want to pack \",\n                \"this\",\n                \" Int into a \",\n                \"buffer of u32, how many do we need?\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    count := big.internal_int_pack_count(a, \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n    buf := make([]\",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", count)\\n    \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" delete(buf)\\n\\n    written: \",\n        {\n            \"children\": [\n                \"int\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n    written, err = big.internal_int_pack(a, buf)\\n    fmt.printf("\\\\nPacked into \",\n        {\n            \"children\": [\n                \"u32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" buf: %v | err: %v | written: %v\\\\n", buf, err, written)\\n\\n    \",\n        {\n            \"children\": [\n                \"// If we\",\n                \" want to pack \",\n                \"this\",\n                \" Int into a \",\n                \"buffer of bytes of\",\n                \" which only the \",\n                \"bottom 6 bits are used, how many do we need?\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    nails := \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"\\n\\n    count = big.internal_int_pack_count(a, \",\n        {\n            \"children\": [\n                \"u8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", nails)\\n    byte_buf := make([]\",\n        {\n            \"children\": [\n                \"u8\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \", count)\\n    \",\n        {\n            \"children\": [\n                \"defer\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" delete(byte_buf)\\n\\n    written, err = big.internal_int_pack(a, byte_buf, nails)\\n    fmt.printf("\\\\nPacked into buf of \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"-bit bytes: %v | err: %v | written: %v\\\\n", byte_buf, err, written)\\n\\n\\n\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" Pick another random \",\n                \"big Int, not necesssarily prime.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    err = big.random(b, \",\n        {\n            \"children\": [\n                \"2048\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n    print_bigint("\\\\n2048 bit random number: ", b)\\n\\n    \",\n        {\n            \"children\": [\n                \"// Calculate GCD + LCM\",\n                \" in one fell \",\n                \"swoop\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    big.gcd_lcm(c, d, a, b)\\n\\n    print_bigint("\\\\nGCD of random prime A and random number B: ", c)\\n    print_bigint("\\\\nLCM of random prime A and random number B (\",\n        {\n            \"children\": [\n                \"in\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" base \",\n        {\n            \"children\": [\n                \"36\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"): ", d, \",\n        {\n            \"children\": [\n                \"36\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n}\\n\\nmatrix_type :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    fmt.println("\\\\n# matrix type")\\n    \",\n        {\n            \"children\": [\n                \"// A\",\n                \" matrix is a \",\n                \"mathematical\",\n                \" type built into \",\n                \"Odin. It\",\n                \" is a regular \",\n                \"array of numbers,\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" arranged in rows \",\n                \"and columns\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \\n    {\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" The following represents \",\n                \"a\",\n                \" matrix that has \",\n                \"2 rows and 3 columns\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        m: matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        \\n        m = matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n            \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", -\",\n        {\n            \"children\": [\n                \"13\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"20\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", -\",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        \\n        \",\n        {\n            \"children\": [\n                \"// Element types of integers, float,\",\n                \" and complex numbers \",\n                \"are supported by matrices.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// There is no support for booleans, quaternions, or any compound type.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Indexing a matrix \",\n                \"can be\",\n                \" used with the \",\n                \"matrix indexing syntax\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" This mirrors othe \",\n                \"type\",\n                \" usages: type on \",\n                \"the left,\",\n                \" usage on the \",\n                \"right\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \\n        elem := m[\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"] \",\n        {\n            \"children\": [\n                \"// row 1, column 2\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        assert(elem == -\",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        \\n        \\n        \",\n        {\n            \"children\": [\n                \"// Scalars act as\",\n                \" if they are \",\n                \"scaled identity matrices\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// and can be\",\n                \" assigned to matrices \",\n                \"as them\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        b := matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{}\\n        f := \",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"(\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        b = f\\n        \\n        fmt.println("b", b)\\n        fmt.println("b == f", b == f)\\n        \\n    } \\n    \\n    { \",\n        {\n            \"children\": [\n                \"//\",\n                \" Matrices support multiplication \",\n                \"between matrices\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        a := matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n            \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        \\n        b := matrix[\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n            \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        \\n        fmt.println("a", a)\\n        fmt.println("b", b)\\n        \\n        c := a * b\\n        #assert(type_of(c) == matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \")\\n        fmt.tprintln("c = a * b", c)        \\n    }\\n    \\n    { \",\n        {\n            \"children\": [\n                \"//\",\n                \" Matrices support multiplication \",\n                \"between matrices and arrays\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        m := matrix[\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n            \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \\n            \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \\n            \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \\n            \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        \\n        v := [\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        \\n        \",\n        {\n            \"children\": [\n                \"// treating 'v' as a column vector\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println("m * v", m * v)\\n        \\n        \",\n        {\n            \"children\": [\n                \"// treating 'v' as a row vector\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        fmt.println("v * m", v * m)\\n        \\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Support with non-square \",\n                \"matrices\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        s := matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{ \",\n        {\n            \"children\": [\n                \"// [4][2]f32\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n            \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \\n            \",\n        {\n            \"children\": [\n                \"7\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"8\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \\n        }\\n        \\n        w := [\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"}\\n        r: [\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \" = w * s\\n        fmt.println("r", r)\\n    }\\n    \\n    { \",\n        {\n            \"children\": [\n                \"// Component-wise operations \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" if the element \",\n                \"type supports it\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Not support for \",\n                \"'/', '%', or '%%' operations\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \\n        a := matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n            \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        \\n        b := matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"i32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"{\\n            -\",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",  \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n             \",\n        {\n            \"children\": [\n                \"9\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", -\",\n        {\n            \"children\": [\n                \"7\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        \\n        c0 := a + b\\n        c1 := a - b\\n        c2 := a & b\\n        c3 := a | b\\n        c4 := a ~ b\\n        c5 := a &~ b\\n\\n        \",\n        {\n            \"children\": [\n                \"// component-wise multiplication\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// since a * b would be\",\n                \" a standard matrix \",\n                \"multiplication\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        c6 := hadamard_product(a, b) \\n        \\n        \\n        fmt.println("a + b",  c0)\\n        fmt.println("a - b",  c1)\\n        fmt.println("a & b",  c2)\\n        fmt.println("a | b",  c3)\\n        fmt.println("a ~ b",  c4)\\n        fmt.println("a &~ b", c5)\\n        fmt.println("hadamard_product(a, b)", c6)\\n    }\\n    \\n    { \",\n        {\n            \"children\": [\n                \"//\",\n                \" Submatrix casting square \",\n                \"matrices\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Casting a square \",\n                \"matrix\",\n                \" to another square \",\n                \"matrix\",\n                \" with same element \",\n                \"type\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// is supported. \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// If\",\n                \" the cast is \",\n                \"to\",\n                \" a smaller matrix \",\n                \"type,\",\n                \" the top-left submatrix \",\n                \"is taken.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// If\",\n                \" the cast is \",\n                \"to\",\n                \" a larger matrix \",\n                \"type,\",\n                \" the matrix is \",\n                \"extended with zeros\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" everywhere and ones \",\n                \"in\",\n                \" the diagonal for \",\n                \"the unfilled elements of the \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"// extended matrix.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \\n        mat2 :: \",\n        {\n            \"children\": [\n                \"distinct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        mat4 :: \",\n        {\n            \"children\": [\n                \"distinct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" matrix[\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        \\n        m2 := mat2{\\n            \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        \\n        m4 := mat4(m2)\\n        assert(m4[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"] == \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        assert(m4[\",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"] == \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \")\\n        fmt.printf("m2 %#v\\\\n", m2)\\n        fmt.println("m4", m4)\\n        fmt.println("mat2(m4)", mat2(m4))\\n        assert(mat2(m4) == m2)\\n        \\n        b4 := mat4{\\n            \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n            \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"7\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"0\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"8\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        fmt.println("b4", matrix_flatten(b4))\\n    }\\n    \\n    { \",\n        {\n            \"children\": [\n                \"// Casting non-square matrices\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Casting a matrix \",\n                \"to\",\n                \" another matrix is \",\n                \"allowed as long as they share \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" the same element \",\n                \"type\",\n                \" and the number \",\n                \"of elements (rows*columns).\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" Matrices in Odin \",\n                \"are\",\n                \" stored in column-major \",\n                \"order, which means\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \",\n        {\n            \"children\": [\n                \"//\",\n                \" the casts will \",\n                \"preserve this element order.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n        \\n        mat2x4 :: \",\n        {\n            \"children\": [\n                \"distinct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" matrix[\",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        mat4x2 :: \",\n        {\n            \"children\": [\n                \"distinct\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" matrix[\",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \"]\",\n        {\n            \"children\": [\n                \"f32\"\n            ],\n            \"scope\": \"built_in\"\n        },\n        \"\\n        \\n        x := mat2x4{\\n            \",\n        {\n            \"children\": [\n                \"1\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"3\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"5\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"7\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \\n            \",\n        {\n            \"children\": [\n                \"2\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"4\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"6\"\n            ],\n            \"scope\": \"number\"\n        },\n        \", \",\n        {\n            \"children\": [\n                \"8\"\n            ],\n            \"scope\": \"number\"\n        },\n        \",\\n        }\\n        \\n        y := mat4x2(x)\\n        fmt.println("x", x)\\n        fmt.println("y", y)\\n    }\\n    \\n    \",\n        {\n            \"children\": [\n                \"// TECHNICAL INFORMATION:\",\n                \" the internal representation \",\n                \"of\",\n                \" a matrix in \",\n                \"Odin is stored\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// in column-major format\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// e.g. matrix[2, 3]f32 is internally [3][2]f32 (with\",\n                \" different a alignment \",\n                \"requirement)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" Column-major is used \",\n                \"in\",\n                \" order to utilize \",\n                \"(SIMD)\",\n                \" vector instructions effectively \",\n                \"on \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// modern hardware, if possible.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// Unlike normal arrays,\",\n                \" matrices try to \",\n                \"maximize\",\n                \" alignment to allow \",\n                \"for the (SIMD) vectorization\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" properties whilst keeping \",\n                \"zero padding (either between columns or\",\n                \" at the end \",\n                \"of the type).\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" Zero padding is \",\n                \"a\",\n                \" compromise for use \",\n                \"with third-party libraries, instead of optimizing for performance.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" Padding between columns \",\n                \"was\",\n                \" not taken even \",\n                \"if\",\n                \" that would have \",\n                \"allowed\",\n                \" each column to \",\n                \"be loaded \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" individually into a \",\n                \"SIMD\",\n                \" register with the \",\n                \"correct alignment properties. \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// Currently,\",\n                \" matrices are limited \",\n                \"to a maximum of 16 elements (rows*columns),\",\n                \" and a minimum \",\n                \"of 1 element.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \" This is because \",\n                \"matrices are stored as values (not a reference type),\",\n                \" and thus operations \",\n                \"on them will\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"// be\",\n                \" stored on the \",\n                \"stack.\",\n                \" Restricting the maximum \",\n                \"element\",\n                \" count minimizing the \",\n                \"possibility of stack overflows.\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \\n    \",\n        {\n            \"children\": [\n                \"// Built-in Procedures (Compiler Level)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  transpose(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//      transposes a matrix\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  outer_product(a, b)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \"      takes two array-like \",\n                \"data\",\n                \" types and returns \",\n                \"the outer product\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//      of\",\n                \" the values in \",\n                \"a matrix\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  hadamard_product(a, b)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//      component-wise multiplication of two matrices of the same type\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  matrix_flatten(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \"      converts the matrix \",\n                \"into\",\n                \" a flatten array \",\n                \"of elements\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//      in column-major order\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//      Example:\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//      m := matrix[2, 2]f32{\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//          x0, x1,\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//          y0, y1, \"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//      }\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//      array: [4]f32 = matrix_flatten(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//      assert(array == {x0, y0, x1, y1})\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  conj(x)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//\",\n                \"      conjugates the elements \",\n                \"of\",\n                \" a matrix for \",\n                \"complex element types only\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \\n    \",\n        {\n            \"children\": [\n                \"// Built-in Procedures (Runtime Level) (all square matrix procedures)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  determinant(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  adjugate(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  inverse(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  inverse_transpose(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  hermitian_adjoint(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  matrix_trace(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n    \",\n        {\n            \"children\": [\n                \"//  matrix_minor(m)\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n}\\n\\nmain :: \",\n        {\n            \"children\": [\n                \"proc\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \"() {\\n    \",\n        {\n            \"children\": [\n                \"/*\\n\",\n                \"        For More Odin \",\n                \"Examples - https://github.com/odin-lang/examples\\n\",\n                \"            This repository contains \",\n                \"examples of\",\n                \" how certain things \",\n                \"can be accomplished \\n            in idiomatic Odin,\",\n                \" allowing you learn \",\n                \"its semantics, as well as\",\n                \" how to use \",\n                \"\\n            parts of\",\n                \" the core and \",\n                \"vendor package collections.\\n    */\"\n            ],\n            \"scope\": \"comment\"\n        },\n        \"\\n\\n    \",\n        {\n            \"children\": [\n                \"when\"\n            ],\n            \"scope\": \"keyword\"\n        },\n        \" \",\n        {\n            \"children\": [\n                \"true\"\n            ],\n            \"scope\": \"literal\"\n        },\n        \" {\\n        the_basics()\\n        control_flow()\\n        named_proc_return_parameters()\\n        explicit_procedure_overloading()\\n        struct_type()\\n        union_type()\\n        using_statement()\\n        implicit_context_system()\\n        parametric_polymorphism()\\n        array_programming()\\n        map_type()\\n        implicit_selector_expression()\\n        partial_switch()\\n        cstring_example()\\n        bit_set_type()\\n        deferred_procedure_associations()\\n        reflection()\\n        quaternions()\\n        unroll_for_statement()\\n        where_clauses()\\n        foreign_system()\\n        ranged_fields_for_array_compound_literals()\\n        deprecated_attribute()\\n        range_statements_with_multiple_return_values()\\n        threading_example()\\n        soa_struct_layout()\\n        constant_literal_expressions()\\n        union_maybe()\\n        explicit_context_definition()\\n        relative_data_types()\\n        or_else_operator()\\n        or_return_operator()\\n        arbitrary_precision_mathematics()\\n        matrix_type()\\n    }\\n}\\n\\n
\\n\"\n ]\n}","_top":{"name":"Odin","aliases":["odin","language-odin"],"keywords":{"asm":["keyword",1],"auto_cast":["keyword",1],"bit_set":["keyword",1],"break":["keyword",1],"case":["keyword",1],"cast":["keyword",1],"context":["keyword",1],"continue":["keyword",1],"defer":["keyword",1],"distinct":["keyword",1],"do":["keyword",1],"dynamic":["keyword",1],"else":["keyword",1],"enum":["keyword",1],"fallthrough":["keyword",1],"for":["keyword",0],"foreign":["keyword",1],"if":["keyword",0],"import":["keyword",1],"in":["keyword",0],"map":["keyword",1],"not_in":["keyword",1],"or_else":["keyword",1],"or_return":["keyword",1],"package":["keyword",1],"proc":["keyword",1],"return":["keyword",1],"struct":["keyword",1],"switch":["keyword",1],"transmute":["keyword",1],"typeid":["keyword",1],"union":["keyword",1],"using":["keyword",1],"when":["keyword",1],"where":["keyword",1],"->":["keyword",1],"true":["literal",1],"false":["literal",1],"nil":["literal",1],"---":["literal",1],"int":["built_in",1],"i8":["built_in",1],"i16":["built_in",1],"i32":["built_in",1],"i64":["built_in",1],"i128":["built_in",1],"uint":["built_in",1],"byte":["built_in",1],"u8":["built_in",1],"u16":["built_in",1],"u32":["built_in",1],"u64":["built_in",1],"u128":["built_in",1],"uintptr":["built_in",1],"bool":["built_in",1],"b8":["built_in",1],"b16":["built_in",1],"b32":["built_in",1],"b64":["built_in",1],"f16":["built_in",1],"f32":["built_in",1],"f64":["built_in",1],"i16le":["built_in",1],"i32le":["built_in",1],"i64le":["built_in",1],"i128le":["built_in",1],"u16le":["built_in",1],"u32le":["built_in",1],"u64le":["built_in",1],"u128le":["built_in",1],"i16be":["built_in",1],"i32be":["built_in",1],"i64be":["built_in",1],"i128be":["built_in",1],"u16be":["built_in",1],"u32be":["built_in",1],"u64be":["built_in",1],"u128be":["built_in",1],"f16le":["built_in",1],"f32le":["built_in",1],"f64le":["built_in",1],"f16be":["built_in",1],"f32be":["built_in",1],"f64be":["built_in",1],"complex32":["built_in",1],"complex64":["built_in",1],"complex128":["built_in",1],"quaternion64":["built_in",1],"quaternion128":["built_in",1],"quaternion256":["built_in",1],"rune":["built_in",1],"string":["built_in",1],"cstring":["built_in",1],"any":["built_in",1],"rawptr":["built_in",1]},"contains":[{"scope":"comment","begin":"//","end":"$","contains":[{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"$","matcher":{"rules":[["[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0}],["[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}",{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1}],["$",{"type":"end","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0},"3":{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1},"7":{"type":"end","position":2}},"regexes":[[{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0},"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)"],[{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1},"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}"],[{"type":"end","position":2},"$"]],"matchAt":8,"position":3,"matcherRe":{},"lastIndex":73191}],"count":2,"lastIndex":73191,"regexIndex":3},"data":{}},{"scope":"comment","begin":"/\\*","end":"\\*/","contains":[{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"\\*/","matcher":{"rules":[["[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0}],["[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}",{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1}],["\\*/",{"type":"end","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0},"3":{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1},"7":{"type":"end","position":2}},"regexes":[[{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0},"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)"],[{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1},"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}"],[{"type":"end","position":2},"\\*/"]],"matchAt":8,"position":3,"matcherRe":{},"lastIndex":73518}],"count":2,"lastIndex":73518,"regexIndex":3},"data":{}},{"scope":"string","begin":"'","end":"'","illegal":"\\n","contains":[{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"'","illegalRe":{},"matcher":{"rules":[["\\\\[\\s\\S]",{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0}],["'",{"type":"end","position":1}],["\\n",{"type":"illegal","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0},"2":{"type":"end","position":1},"3":{"type":"illegal","position":2}},"regexes":[[{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0},"\\\\[\\s\\S]"],[{"type":"end","position":1},"'"],[{"type":"illegal","position":2},"\\n"]],"matchAt":4,"position":3,"matcherRe":{},"lastIndex":60489}],"count":1,"lastIndex":60489,"regexIndex":2},"data":{}},{"scope":"string","begin":"\"","end":"\"","illegal":"\\n","contains":[{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"\"","illegalRe":{},"matcher":{"rules":[["\\\\[\\s\\S]",{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0}],["\"",{"type":"end","position":1}],["\\n",{"type":"illegal","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0},"2":{"type":"end","position":1},"3":{"type":"illegal","position":2}},"regexes":[[{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0},"\\\\[\\s\\S]"],[{"type":"end","position":1},"\""],[{"type":"illegal","position":2},"\\n"]],"matchAt":4,"position":3,"matcherRe":{},"lastIndex":18}],"count":1,"lastIndex":18,"regexIndex":2},"data":{}},{"begin":"`","end":"`","contains":[],"relevance":0,"scope":"string","__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"`","matcher":{"rules":[["`",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"`"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":44480}],"count":0,"lastIndex":44480,"regexIndex":1},"data":{}},{"begin":"\\b([0-9](_?[0-9])*|(0x|0o|0b)[0-9a-fA-F](_?[0-9a-fA-F])*)(\\.([0-9](_?[0-9])*)?)?([eE][-+]?[0-9](_?[0-9])*)?([pP][-+]?[0-9](_?[0-9])*)?[iufb]?","relevance":0,"scope":"number","__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":70859}],"count":0,"lastIndex":70859,"regexIndex":1},"data":{}}],"compilerExtensions":[],"classNameAliases":{},"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"matcher":{"rules":[["//",{"rule":{"scope":"comment","begin":"//","end":"$","contains":[{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"$","matcher":{"rules":[["[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0}],["[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}",{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1}],["$",{"type":"end","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0},"3":{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1},"7":{"type":"end","position":2}},"regexes":[[{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0},"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)"],[{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1},"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}"],[{"type":"end","position":2},"$"]],"matchAt":8,"position":3,"matcherRe":{},"lastIndex":73191}],"count":2,"lastIndex":73191,"regexIndex":3},"data":{}},"type":"begin","position":0}],["/\\*",{"rule":{"scope":"comment","begin":"/\\*","end":"\\*/","contains":[{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"\\*/","matcher":{"rules":[["[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0}],["[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}",{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1}],["\\*/",{"type":"end","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0},"3":{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1},"7":{"type":"end","position":2}},"regexes":[[{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0},"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)"],[{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1},"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}"],[{"type":"end","position":2},"\\*/"]],"matchAt":8,"position":3,"matcherRe":{},"lastIndex":73518}],"count":2,"lastIndex":73518,"regexIndex":3},"data":{}},"type":"begin","position":1}],["'",{"rule":{"scope":"string","begin":"'","end":"'","illegal":"\\n","contains":[{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"'","illegalRe":{},"matcher":{"rules":[["\\\\[\\s\\S]",{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0}],["'",{"type":"end","position":1}],["\\n",{"type":"illegal","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0},"2":{"type":"end","position":1},"3":{"type":"illegal","position":2}},"regexes":[[{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0},"\\\\[\\s\\S]"],[{"type":"end","position":1},"'"],[{"type":"illegal","position":2},"\\n"]],"matchAt":4,"position":3,"matcherRe":{},"lastIndex":60489}],"count":1,"lastIndex":60489,"regexIndex":2},"data":{}},"type":"begin","position":2}],["\"",{"rule":{"scope":"string","begin":"\"","end":"\"","illegal":"\\n","contains":[{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"\"","illegalRe":{},"matcher":{"rules":[["\\\\[\\s\\S]",{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0}],["\"",{"type":"end","position":1}],["\\n",{"type":"illegal","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0},"2":{"type":"end","position":1},"3":{"type":"illegal","position":2}},"regexes":[[{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0},"\\\\[\\s\\S]"],[{"type":"end","position":1},"\""],[{"type":"illegal","position":2},"\\n"]],"matchAt":4,"position":3,"matcherRe":{},"lastIndex":18}],"count":1,"lastIndex":18,"regexIndex":2},"data":{}},"type":"begin","position":3}],["`",{"rule":{"begin":"`","end":"`","contains":[],"relevance":0,"scope":"string","__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"`","matcher":{"rules":[["`",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"`"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":44480}],"count":0,"lastIndex":44480,"regexIndex":1},"data":{}},"type":"begin","position":4}],["\\b([0-9](_?[0-9])*|(0x|0o|0b)[0-9a-fA-F](_?[0-9a-fA-F])*)(\\.([0-9](_?[0-9])*)?)?([eE][-+]?[0-9](_?[0-9])*)?([pP][-+]?[0-9](_?[0-9])*)?[iufb]?",{"rule":{"begin":"\\b([0-9](_?[0-9])*|(0x|0o|0b)[0-9a-fA-F](_?[0-9a-fA-F])*)(\\.([0-9](_?[0-9])*)?)?([eE][-+]?[0-9](_?[0-9])*)?([pP][-+]?[0-9](_?[0-9])*)?[iufb]?","relevance":0,"scope":"number","__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":70859}],"count":0,"lastIndex":70859,"regexIndex":1},"data":{}},"type":"begin","position":5}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"scope":"comment","begin":"//","end":"$","contains":[{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"$","matcher":{"rules":[["[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0}],["[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}",{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1}],["$",{"type":"end","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0},"3":{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1},"7":{"type":"end","position":2}},"regexes":[[{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0},"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)"],[{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1},"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}"],[{"type":"end","position":2},"$"]],"matchAt":8,"position":3,"matcherRe":{},"lastIndex":73191}],"count":2,"lastIndex":73191,"regexIndex":3},"data":{}},"type":"begin","position":0},"2":{"rule":{"scope":"comment","begin":"/\\*","end":"\\*/","contains":[{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"\\*/","matcher":{"rules":[["[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0}],["[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}",{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1}],["\\*/",{"type":"end","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0},"3":{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1},"7":{"type":"end","position":2}},"regexes":[[{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0},"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)"],[{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1},"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}"],[{"type":"end","position":2},"\\*/"]],"matchAt":8,"position":3,"matcherRe":{},"lastIndex":73518}],"count":2,"lastIndex":73518,"regexIndex":3},"data":{}},"type":"begin","position":1},"3":{"rule":{"scope":"string","begin":"'","end":"'","illegal":"\\n","contains":[{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"'","illegalRe":{},"matcher":{"rules":[["\\\\[\\s\\S]",{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0}],["'",{"type":"end","position":1}],["\\n",{"type":"illegal","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0},"2":{"type":"end","position":1},"3":{"type":"illegal","position":2}},"regexes":[[{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0},"\\\\[\\s\\S]"],[{"type":"end","position":1},"'"],[{"type":"illegal","position":2},"\\n"]],"matchAt":4,"position":3,"matcherRe":{},"lastIndex":60489}],"count":1,"lastIndex":60489,"regexIndex":2},"data":{}},"type":"begin","position":2},"4":{"rule":{"scope":"string","begin":"\"","end":"\"","illegal":"\\n","contains":[{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"\"","illegalRe":{},"matcher":{"rules":[["\\\\[\\s\\S]",{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0}],["\"",{"type":"end","position":1}],["\\n",{"type":"illegal","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0},"2":{"type":"end","position":1},"3":{"type":"illegal","position":2}},"regexes":[[{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0},"\\\\[\\s\\S]"],[{"type":"end","position":1},"\""],[{"type":"illegal","position":2},"\\n"]],"matchAt":4,"position":3,"matcherRe":{},"lastIndex":18}],"count":1,"lastIndex":18,"regexIndex":2},"data":{}},"type":"begin","position":3},"5":{"rule":{"begin":"`","end":"`","contains":[],"relevance":0,"scope":"string","__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"`","matcher":{"rules":[["`",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"`"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":44480}],"count":0,"lastIndex":44480,"regexIndex":1},"data":{}},"type":"begin","position":4},"6":{"rule":{"begin":"\\b([0-9](_?[0-9])*|(0x|0o|0b)[0-9a-fA-F](_?[0-9a-fA-F])*)(\\.([0-9](_?[0-9])*)?)?([eE][-+]?[0-9](_?[0-9])*)?([pP][-+]?[0-9](_?[0-9])*)?[iufb]?","relevance":0,"scope":"number","__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":70859}],"count":0,"lastIndex":70859,"regexIndex":1},"data":{}},"type":"begin","position":5}},"regexes":[[{"rule":{"scope":"comment","begin":"//","end":"$","contains":[{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"$","matcher":{"rules":[["[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0}],["[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}",{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1}],["$",{"type":"end","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0},"3":{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1},"7":{"type":"end","position":2}},"regexes":[[{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":58414}],"count":0,"lastIndex":58414,"regexIndex":1},"data":{}},"type":"begin","position":0},"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)"],[{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":72935}],"count":0,"lastIndex":72935,"regexIndex":1},"data":{}},"type":"begin","position":1},"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}"],[{"type":"end","position":2},"$"]],"matchAt":8,"position":3,"matcherRe":{},"lastIndex":73191}],"count":2,"lastIndex":73191,"regexIndex":3},"data":{}},"type":"begin","position":0},"//"],[{"rule":{"scope":"comment","begin":"/\\*","end":"\\*/","contains":[{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"\\*/","matcher":{"rules":[["[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0}],["[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}",{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1}],["\\*/",{"type":"end","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0},"3":{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1},"7":{"type":"end","position":2}},"regexes":[[{"rule":{"scope":"doctag","begin":"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)","end":{},"excludeBegin":true,"relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):","contains":[],"matcher":{"rules":[["(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):"]],"matchAt":3,"position":1,"matcherRe":{},"lastIndex":2206}],"count":0,"lastIndex":2206,"regexIndex":1},"data":{}},"type":"begin","position":0},"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)"],[{"rule":{"begin":"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}","__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":73518}],"count":0,"lastIndex":73518,"regexIndex":1},"data":{}},"type":"begin","position":1},"[ ]+((?:I|a|is|so|us|to|at|if|in|it|on|[A-Za-z]+['](d|ve|re|ll|t|s|n)|[A-Za-z]+[-][a-z]+|[A-Za-z][a-z]{2,})[.]?[:]?([.][ ]|[ ])){3}"],[{"type":"end","position":2},"\\*/"]],"matchAt":8,"position":3,"matcherRe":{},"lastIndex":73518}],"count":2,"lastIndex":73518,"regexIndex":3},"data":{}},"type":"begin","position":1},"/\\*"],[{"rule":{"scope":"string","begin":"'","end":"'","illegal":"\\n","contains":[{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"'","illegalRe":{},"matcher":{"rules":[["\\\\[\\s\\S]",{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0}],["'",{"type":"end","position":1}],["\\n",{"type":"illegal","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0},"2":{"type":"end","position":1},"3":{"type":"illegal","position":2}},"regexes":[[{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":25360}],"count":0,"lastIndex":25360,"regexIndex":1},"data":{}},"type":"begin","position":0},"\\\\[\\s\\S]"],[{"type":"end","position":1},"'"],[{"type":"illegal","position":2},"\\n"]],"matchAt":4,"position":3,"matcherRe":{},"lastIndex":60489}],"count":1,"lastIndex":60489,"regexIndex":2},"data":{}},"type":"begin","position":2},"'"],[{"rule":{"scope":"string","begin":"\"","end":"\"","illegal":"\\n","contains":[{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}}],"__beforeBegin":null,"relevance":1,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"\"","illegalRe":{},"matcher":{"rules":[["\\\\[\\s\\S]",{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0}],["\"",{"type":"end","position":1}],["\\n",{"type":"illegal","position":2}]],"multiRegexes":[{"matchIndexes":{"1":{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0},"2":{"type":"end","position":1},"3":{"type":"illegal","position":2}},"regexes":[[{"rule":{"begin":"\\\\[\\s\\S]","relevance":0,"__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end"}]],"multiRegexes":[],"count":0,"lastIndex":0,"regexIndex":0}},"type":"begin","position":0},"\\\\[\\s\\S]"],[{"type":"end","position":1},"\""],[{"type":"illegal","position":2},"\\n"]],"matchAt":4,"position":3,"matcherRe":{},"lastIndex":18}],"count":1,"lastIndex":18,"regexIndex":2},"data":{}},"type":"begin","position":3},"\""],[{"rule":{"begin":"`","end":"`","contains":[],"relevance":0,"scope":"string","__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"endRe":{},"terminatorEnd":"`","matcher":{"rules":[["`",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"`"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":44480}],"count":0,"lastIndex":44480,"regexIndex":1},"data":{}},"type":"begin","position":4},"`"],[{"rule":{"begin":"\\b([0-9](_?[0-9])*|(0x|0o|0b)[0-9a-fA-F](_?[0-9a-fA-F])*)(\\.([0-9](_?[0-9])*)?)?([eE][-+]?[0-9](_?[0-9])*)?([pP][-+]?[0-9](_?[0-9])*)?[iufb]?","relevance":0,"scope":"number","__beforeBegin":null,"isCompiled":true,"keywordPatternRe":{},"beginRe":{},"end":{},"endRe":{},"terminatorEnd":"\\B|\\b","contains":[],"matcher":{"rules":[["\\B|\\b",{"type":"end","position":0}]],"multiRegexes":[{"matchIndexes":{"1":{"type":"end","position":0}},"regexes":[[{"type":"end","position":0},"\\B|\\b"]],"matchAt":2,"position":1,"matcherRe":{},"lastIndex":70859}],"count":0,"lastIndex":70859,"regexIndex":1},"data":{}},"type":"begin","position":5},"\\b([0-9](_?[0-9])*|(0x|0o|0b)[0-9a-fA-F](_?[0-9a-fA-F])*)(\\.([0-9](_?[0-9])*)?)?([eE][-+]?[0-9](_?[0-9])*)?([pP][-+]?[0-9](_?[0-9])*)?[iufb]?"]],"matchAt":18,"position":6,"matcherRe":{},"lastIndex":73552}],"count":6,"lastIndex":73552,"regexIndex":0}},"code":"